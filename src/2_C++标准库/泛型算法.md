# 泛型算法

## 概述

绝大部分算法定义在 `<algorithm>` 头文件中。标准库还在 `<numeric>` 头文件中定义了一些数字算法。

泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。

## 初识泛型算法

算法有固定的结构，理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。

### 只读算法

只读算法只读取范围中的元素，不改变元素。如 `find` 、 `accumulate` 和 `count `。建议在只读算法中使用 `cbegin` 和 `cend` 函数。

#### `find`

由于 `find` 仅对迭代器操作，可以将 `find` 用于任何的容器类型，可以将 `find` 用于数组：

```
int ia[] = {27,210,12,47,109,83};
int val = 83;
int* result = find(begin(ia), end(ia), val);
```

#### accumulate

调用 `accumulate` 将 `vector` 中的元素拼接起来：

```
string sum = accumulate(v.cbegin(), v.cend(), string(""));
//@ 注意，此处第三个参数不能是字面值常量
string sum = accumulate(v.cbegin(), v.cend(), ""); //@ 错误，const char* 上没有加操作符
```

#### `equal`

`equal` 用于判断是否两个序列中的值完全一样。这个算法有三个迭代器：前两个表示第一个序列的范围，首元素和尾后迭代器；第三个是第二个序列的首元素：

```
//@ roster2 至少要有与 roster1 一样多的元素
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

- 由于 `equal` 在是迭代器上定义的，可以将 `equal` 用于比较不同类型的容器中的元素。甚至，元素类型也不需要完全一致，只要可以使用 `==` 进行元素值比较就行。如，`roster1` 可以是 `vector<string>` ，`roster2` 可以是 `list<const char*>` 。
- `equal` 做出了一个严格的假设：它假设第二个序列至少跟第一个序列一样长。这个算法潜在地会遍历第一个序列中的所有元素。它假设第二个序列中一定会有对应的元素。

### 写容器元素的算法

一些算法会给序列中的元素赋予新值。当使用会对元素赋值的算法时需要注意，必须保证算法写入的序列其大小大于等于需要写入的数目。

**算法不会直接调用任何容器的操作，所以它们本身没有任何办法改变容器的大小。**

#### `fill` 和 `fill_n`

`fill` 函数接受两个迭代器参数表示序列范围，还接受一个值作为第三个参数，它将给定值赋予范围内的每个元素。 

```
fill(vec.begin(), vec.end(), 0);
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
```

- 由于 `fill` 只会往给定的输入序列中写入值，只要传入的是合法的输入序列，那么写入将是安全的。

`fill_n ` 函数接受单个迭代器参数、一个计数值和一个值，它将给定值赋予迭代器指向位置开始的指定个元素。

 ```
//@ 重置 vec 中所有元素为0
fill_n(vec.begin(), vec.size(), 0);
 ```

- `fill_n` 假设写入指定数目的元素是安全的。这是因为在调用 `fill_n(dest, n, val)` 中，`fill_n` 假设 `dest` 表示一个元素，并且从 `dest` 开始至少有 `n` 个元素。

#### `back_inserter`

使用插入迭代器的算法保证有足够的元素用以写入，插入迭代器是往容器中添加元素的迭代器。当我们给插入迭代器赋值时，一个等于右边值的新元素被添加到容器中。

`back_inserter` 以容器引用为参数，返回一个绑定到容器上的插入迭代器。当通过这个迭代器给元素赋值时，将调用容器的 `push_back` 函数给容器添加元素。如：

```
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
```

在每次迭代时，`fill_n` 给序列中的元素赋值，由于我们传入的是 `back_inserter` 的返回值，每次赋值都将调用 `vec` 的 `push_back` ，因而每次赋值 `fill_n` 都会添加一个元素到容器的尾部。

#### 拷贝算法

`copy` 算法是另一个将值写入到由目的迭代器表示的输出序列中的例子。

这个算法只有三个参数。前两个表示输入序列；第三个表示输出序列的首元素。

```
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
```

- 传递给 `copy` 的输出序列至少要和输入序列一样长。

#### `replace` 和 `replace_copy`

`replace` 算法接收四个参数：两个迭代器表示输入序列，以及两个值。它将序列中的每个等于第一个值的元素替换为第二个值。

```
replace(ilist.begin(), ilist.end(), 0, 42); //@ 将0替换为42
```

如果想要保持原始的容器不变的话，需要调用 `replace_copy` ，这个算法有第三个迭代器参数表示输出目的地。如：

```
replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), 0, 42);
```

- 在此调用之后 `ilist` 将保持不变，而 `ivec` 的元素将是 `ilist` 拷贝，并将其中所有的 0 替换为 42。

### 重排容器元素的算法

有些算法对容器中的元素进行重排序，一个显著的例子就是 `sort` 算法。调用 `sort` 将使用元素的 `<` 操作符将输入范围内的元素排序。

#### 消除元素

首先对这些字符串进行排序。然后调用 `unique` 将所有唯一的字符串放到容器的首部，并返回最后一个唯一字符串的下一个位置的迭代器。`unique` 本身是不改变容器的大小的，所以需要用容器的 `erase` 成员移除元素：

```
void elimDups(vector<string> &words)
{
    sort(words.begin(), words.end());
    auto end_unique = unique(words.begin(), words.end());
    words.erase(end_unique, words.end());
}
```

- 由于标准库算法是在迭代器而不是容器上进行操作，算法不能直接添加或移除元素。

## 定制操作

默认情况下，很多比较算法使用元素类型的 `<` 或 `==` 运算符完成操作。可以为这些算法提供自定义操作来代替默认运算符。

### 传递函数给算法

谓词是一个可以被调用然后返回一个值的表达式，返回值可以作为条件使用。标准库算法使用的谓词分为：

- 一元谓词：接受一个参数。
- 二元谓词：接受两个参数。

带有谓词的算法在输入范围内的元素上调用这个谓词。因而，必须要可以将元素类型转为谓词的参数类型。

```
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}
sort(words.begin(), words.end(), isShorter);
```

通过调用 `stable_sort` 可以保持相同长度的字符串的字典顺序：

```
stable_sort(words.begin(), words.end(), isShorter);
```

### `lambda` 表达式

传递给算法的谓词必须有一个或两个参数。但是有时我们想传递多于算法的谓词需要的参数。

使用 `find_if` 标准库算法来查找大于等于给定长度的元素：

```
void biggies(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words);
    stable_sort(words.begin(), words.end(), isShorter);
    auto wc = find_if(words.begin(), words.end(), [sz](const string &a) {
        return a.size() >= sz;
    });
}
```

-  `find_if` 接收的是一元谓词，任何传递给 `find_if` 的函数必须只有一个参数。所以想要传递可变的 `size` 参数给谓词必须使用 `lambda` 表达式。

对于一个对象或表达式，如果可以对其使用调用运算符`()`，则称它为可调用对象。可以向算法传递任何类别的可调用对象。

一个`lambda`表达式表示一个可调用的代码单元，类似未命名的内联函数，但可以定义在函数内部。其形式如下：

```
[capture list] (parameter list) -> return type { function body }
```

- `capture list`：（捕获列表）是一个由`lambda`所在函数定义的局部变量的列表（通常为空）。
- `return type`、`parameter list` 和 `function body` 与普通函数一样，分别表示返回类型、参数列表和函数体。
- `lambda` 必须使用尾置返回类型，且不能有默认实参。
- 定义 `lambda` 时可以省略参数列表和返回类型，但必须包含捕获列表和函数体。
  - 省略参数列表等价于指定空参数列表。
  - 省略返回类型时，若函数体只是一个 `return` 语句，则返回类型由返回表达式的类型推断而来。否则返回类型为 `void`。
- `lambda ` 可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中。
  - 捕获列表只能用于局部非 `static` 变量，`lambda ` 可以直接使用局部 `static` 变量和其所在函数之外声明的名字。

`for_each ` 函数接受一个输入序列和一个可调用对象，它对输入序列中的每个元素调用此对象。

```
for_each(wc, words.end(),
            [] (const string &s) { cout << s << " "; });
```

#### lambda捕获

被 `lambda` 捕获的变量的值是在 `lambda` 创建时拷贝，而不是调用时拷贝。在 `lambda` 创建后修改局部变量不会影响 `lambda` 内对应的值。

以下是所有的捕获方式：

- `[]` ：空的捕获列表。`lambda` 不适用外围函数中的变量。
- `[names]`：`names `是逗号分隔的捕获列表。默认情况下，变量是值捕获的。在名字前加上 `&` 就是引用捕获。
- `[&]` ：隐式引用捕获列表。在 `lambda` 函数体中所使用的外围函数的本地变量都被隐式地引用捕获。
- `[=]` ：隐式值捕获列表。在 `lambda` 函数体中所使用的外围函数本地变量都被隐式地值捕获。
- `[&,identifier_list]` ：`identifier_list` 是逗号分隔的外围函数本地变量列表，这些变量是值捕获的，并且不能在名字前加上 `&`，其它的使用到外围本地变量是隐式引用捕获的。
- `[=,reference_list]`：`reference_list` 是逗号分隔的外围函数的本地变量引用列表，这些变量是引用捕获的，所以必须在名字前加上 `&`，这个列表不能包括 `this` 指针。其它使用到的外围本地变量都是隐式值捕获的。

注意：

- 当我们进行引用捕获时，一定要保证当 lambda 执行时变量是存在的。
- 引用捕获有时是必须的，比如不可复制的对象：

```
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ')
{
    for_each(words.begin(), words.end(), [&os, c](const string &s) { os << s << c; });
}
```

- 可以从函数中返回 `lambda` ，如果函数返回 `lambda` ，那么与函数不能返回本地变量的引用一样，这个 `lambda` 一定不能包含引用捕获。

#### Mutable Lambda

默认情况下，`lambda` 不会改变按值捕获的变量值，如果想要改变捕获变量的值，必须在参数列表后加上关键词 `mutable`。有 `mutable` 关键词的 `lambda` 不能省略参数列表：

```
void fcn3()
{
    size_t v1 = 42;
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f();
}
```

按引用捕获的对象是否可以改变仅仅依赖于引用的对象是 `const` 还是非 `const`  的：

 ```
void fcn4()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return ++v1; };
    v1 = 0;
    auto j = f2();
}
 ```

#### 指定lambda的返回类型

 `lambda` 表达式只有一个 `return` 语句时，不需要指定返回类型。

如果 `lambda` 函数体中包含了任何不是 `return` 语句的话，那么 `lambda` 将被推断为返回 `void`。推断为返回 `void` 的 `lambda` 不会返回任何值。

如果 `lambda` 中语句多于一条，我们必须指定其返回值：

````
transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int {
    if (i < 0)
        return -i;
    else
        return i;
});
````

###  绑定实参

`bind`函数定义在头文件 `<functional>` 中，相当于一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。`bind` 的通用形式是：

```
auto newCallable = bind(callable, arg_list);
```

- `newCallable` 本身是一个可调用对象。
- `arg_list` 是一个以逗号分隔的参数列表，对应给定的 `callable` 的参数。
- 调用 `newCallable` 时，`newCallable` 会再调用 `callable`，并传递给它 `arg_list` 中的参数。
- `arg_list` 中可能包含形如 `_n` 的名字，其中 `n` 是一个整数。这些参数是占位符，表示 `newCallable` 的参数，它们占据了传递给 `newCallable` 的参数的位置。数值 `n` 表示生成的可调用对象中参数的位置：`_1`为`newCallable` 的第一个参数，`_2`为 `newCallable` 的第二个参数，依次类推。这些名字都定义在命名空间`placeholders` 中，它又定义在命名空间 `std` 中，因此使用时应该进行双重限定。

#### 将sz绑定到check_size上

```
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}
```

以下是给 `check_size` 绑定一个固定的 `sz` 参数：

```
auto check6 = bind(check_size, _1, 6);
```

- `bind` 只有一个占位符，意味着 `check6` 有一个参数。
- 占位符出现在 `arg_list` 的第一个位置，意味着 `check6` 的参数对应于 `check_size` 的第一个参数。这个参数的类型是 `const string&`，意味着 `check6` 中的参数也是 `const string&`。那么当调用 `check6` 时就必须传递类型为 `string` 的参数，`check6` 会将其传递给 `check_size` 的第一个参数。
- `arg_list` 中的第二个参数是值 6，这个值被绑定到 `check_size` 的第二个参数上，无论任何时候我们调用 `check6`，它都会将 6 传递给 `check_sz` 的第二个参数。

`bind` 还可以用于重排序参数。如：

```
auto g = bind(f, a, b, _2, c, _1);
```

 `g` 的第一个参数被传递给 `f` 的第五个参数，`g`  的第二个参数将被传递给 `f`  的第四个参数。

#### 绑定引用形参

```
ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}
```

由于 `os` 不能被拷贝，所以不能直接 `bind` 这个参数。如果想要以引用方式进行绑定需要调用 `ref` 函数： 

```
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```

`ref` 将返回一个对象其本身是可以被拷贝的，然而它的内部包含了给定参数对象的引用。同时还有一个 `cref` 函数用于生成一个类以容纳 `const` 引用。`ref` 和 `cref` 都定义在 `<functional>` 头文件中。

#### 向后兼容：绑定参数

早期的 C++ 版本对于绑定参数到函数有诸多限制，并且更加复杂。标准库定义了 `bind1st` 和 `bind2nd`，在新标准下应该使用 `bind` 函数。

## 再探迭代器

除了为每种容器定义的迭代器之外，标准库还在头文件`<iterator>` 中定义了另外几种迭代器：

| 迭代器                           | 解释                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 插入迭代器（`insert iterator`）  | 该类型迭代器被绑定到容器对象上，可用来向容器中插入元素。     |
| 流迭代器（`stream iterator`）    | 该类型迭代器被绑定到输入或输出流上，可用来遍历所关联的 IO 流。 |
| 反向迭代器（`reverse iterator`） | 该类型迭代器向后而不是向前移动。除了`forward_list`之外的标准库容器都有反向迭代器。 |
| 移动迭代器（`move iterator`）    | 该类型迭代器用来移动容器元素。                               |

### 插入迭代器

插入器是一个迭代器适配器，以一个容器为参数，生成一个可以插入元素的迭代器。当通过插入迭代器赋值时，迭代器将调用容器的操作添加一个元素到指定的位置。这些迭代器支持的操作包括：

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `it = t`            | 插入值到 `it` 所表示的当前位置，根据不同种类的插入迭代器，可能会调用容器的 `push_back` ，`push_front` 或 `insert` 方法。 |
| `*it` `++it` `it++` | 这些操作存在当不做任何事情，每次都是返回 `it` 本身。         |

有三种不同种类的插入器。它们之间的区别在于元素插入到哪个位置：

| 插入迭代器         | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `back_inserter()`  | 这个迭代器调用容器的 `push_back`。                           |
| `front_inserter()` | 这个迭代器调用容器的 `push_front`。                          |
| `inserter()`       | 这个迭代器调用 `insert`，`inserter` 有第二个参数，并且这个参数必须是容器中的迭代器。元素被插入到给定迭代器所表示的元素前面。 |

只有容器有 `push_front` 函数时才能使用 `front_inserter` ，同样只有容器有 `push_back` 时才能使用 `back_inserter`。

当使用 `front_inserter` 时，元素总是被插入到首元素之前，意味着后面插入的元素在前面插入的元素之前。而 `inserter` 生成的迭代器刚好相反，后面插入的元素在前面插入的元素之后。如：

```
list<int> lst = {1,2,3,4};
list<int> lst2, lst3;

//@ copy 完成后，lst2 的内容是 4 3 2 1
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
//@ copy 完成后，lst2 的内容是 1 2 3 4
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
```

### `iostream` 迭代器

使用流迭代器，我们可以使用通用算法对流对象进行读写：

| 流迭代器           | 操作         |
| ------------------ | ------------ |
| `istream_iterator` | 读取输入流。 |
| `ostream_iterator` | 写输出流。   |

`istream_iterator` 的操作：

| 操作                          | 解释                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `istream_iterator<T> in(is);` | `in` 从 `is `中读取类型 `T` 的值。                           |
| `istream_iterator<T> end;`    | `in` 的尾后迭代器。                                          |
| `in1 == in2` `in1 != in2`     | `in1` 和 `in2` 必须读取相同类型的值。它们只有都是 `end` 值或者绑定到同一个输入流上时才相等。 |
| `*in`                         | 返回从流中读取到值。                                         |
| `in->mem` 、`(*in).mem`       | 含义相同，访问读取到的值的成员 `mem`。                       |
| `++in、` `in++`               | 从流中读取下一个值，使用的操作符是元素成员的 `>>` 操作符。前置版本返回自增后的迭代器，后置版本返回旧的迭代器。 |

```
istream_iterator<int> in_iter(cin);
istream_iterator<int> eof;
while (in_iter != eof)
    vec.push_back(*in_iter++);
```

只有当要给迭代器绑定的流到达了文件尾部或者遇到了 IO 错误时才会等于 `end` 迭代器。

使用 `istream_iterator` 用于初始化 `vector`：

```
istream_iterator<int> in_iter(cin), eof;
vector<int> vec(in_iter, eof);
```

将 `istream_iterator` 用于算法：

```
istream_iterator<int> in(cin), eof;
cout << std::accumulate(in, eof, 0) << endl;
```

将`istream_iterator ` 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。但可以保证在第一次解引用迭代器之前，从流中读取数据的操作已经完成了。

 `ostream_iterator` 的操作：

| 操作                              | 解释                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os);`    | `out` 将类型 `T` 的值写入到输出流 `os` 中。                  |
| `ostream_iterator<T> out(os, d);` | `out` 将类型 `T` 的值和 `d` 一起写入到输出流 `os` 中，`d` 是一个 C 风格字符串的指针，每次写入时 `d` 都在 `T` 值的前面。 |
| `out = val;`                      | 将 `val` 通过 `out` 写入到其绑定的输出流中，使用的 `val` 的 `<<` 操作符。`val` 的类型必须与 `out` 可写的对象类型相兼容。 |
| `*out`、 `++out` 、`out++`        | 这些操作存在但是没有做什么事，每个操作都返回`out`。          |

注意：

- `ostream_iterator` 可以定义在任何有 `<<` 操作符的元素类型。
- 创建 `ostream_iterator` 时可以提供第二参数是一个字符串，这个字符串必须是 C 风格字符串，它将在任何元素打印之前先打印。
- `ostream_iterator` 必须与特定的流绑定，并且没有尾后迭代器。

使用 `ostream_iterator` 写入一系列的值：

```
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
    *out_iter++ = e;
cout << endl;
```

除了自己写循环之外，我们还可以调用 copy 算法，如：

```
copy(vec.begin(), vec.end(), out_iter);
```

### 反向迭代器

反向迭代器是一种反向遍历容器的迭代器。

- 反向迭代器反转了自增和自减的含义。自增一个反向迭代器会将迭代器移动到前一个元素；自减则会将迭代器移动到下一个元素。
- 通过调用 `rbegin`，`rend`，`crbegin` 和 `crend` 成员函数来获取反向迭代器。
- 与正常的迭代器一样，反向迭代器分为 `const` 和非 `const` 的。
- 只有同时支持自减和自增操作符的迭代器才能定义反向迭代器。
  - 除了 `forward_list` ，所有标准容器的迭代器都同时支持自减和自增操作。
  - 流迭代器不支持自减操作，毕竟它不能反向移动。
- `reverse_iterator` 有一个 `base` 成员，返回其对应的正常迭代器。

在反向迭代器上调用 `sort` 将容器中的元素按照相反的顺序排序。如：

```
sort(vec.begin(), vec.end());
sort(vec.rbegin(), vec.rend());
```

## 泛型算法结构

### 按照五种迭代器分类

算法要求的迭代器操作被分类为五种迭代器类别，每个算法都说明了其每个迭代器参数所属的类别：

- 输入迭代器（`input iterator`）：可以读取序列中的元素，只能用于单遍扫描算法。必须支持以下操作：
  - 用于比较两个迭代器相等性的相等运算符 `==` 和不等运算符 `!=`。
  - 用于推进迭代器位置的前置和后置递增运算符 `++`。
  - 用于读取元素的解引用运算符 `*`；解引用只能出现在赋值运算符右侧。
  - 用于读取元素的箭头运算符 `->`。
- 输出迭代器（`output iterator`）：可以读写序列中的元素，只能用于单遍扫描算法，通常指向目的位置。必须支持以下操作：
  - 用于推进迭代器位置的前置和后置递增运算符 `++`。
  - 用于读取元素的解引用运算符 `*`；解引用只能出现在赋值运算符左侧（向已经解引用的输出迭代器赋值，等价于将值写入其指向的元素）。
- 前向迭代器（`forward iterator`）：可以读写序列中的元素。只能在序列中沿一个方向移动。支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此可以使用前向迭代器对序列进行多遍扫描。
- 双向迭代器（`bidirectional iterator`）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，还支持前置和后置递减运算符`--`。除 `forward_list` 之外的其他标准库容器都提供符合双向迭代器要求的迭代器。
- 随机访问迭代器（`random-access iterator`）：可以在常量时间内访问序列中的任何元素。除了支持所有双向迭代器的操作之外，还必须支持以下操作：
  - 用于比较两个迭代器相对位置的关系运算符 `<`、`<=`、`>`、`>=`。
  - 迭代器和一个整数值的加减法运算 `+`、`+=`、`-`、`-=`，计算结果是迭代器在序列中前进或后退给定整数个元素后的位置。
  - 用于两个迭代器上的减法运算符 `-`，计算得到两个迭代器的距离。
  - 下标运算符 `[]`。

### 按照算法的参数模式分配

大多数算法的形参模式是以下四种形式之一：

```
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```

- `alg` 是算法名称。
- `beg` 和 `end` 表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于算法操作。
- `dest` 表示输出范围。
- `beg2` 和 `end2` 表示第二个输入范围。

注意：

- 向输出迭代器写入数据的算法都假定目标空间足够容纳要写入的数据。
- 接受单独一个迭代器参数表示第二个输入范围的算法都假定从迭代器参数开始的序列至少与第一个输入范围一样大。

### 算法名字的约定

接受谓词参数的算法都有附加的 `_if` 后缀 ：

```
find(beg, end, val);    
find_if(beg, end, pred);  
```

将执行结果写入额外目的空间的算法都有 `_copy` 后缀：

```
reverse(beg, end);     
reverse_copy(beg, end, dest);   
```

一些算法同时提供 `_copy` 和 `_if` 版本。

## 特定容器算法

对于 `list` 和 `forward_list` 类型，应该优先使用成员函数版本的算法，而非通用算法。

`list ` 和 `forward_list` 成员函数版本的算法：

| 操作                                        | 解释                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| `lst.merge(lst2)`、 `lst.merge(lst2, comp)` | 将  `lst2` 上的元素合并到`lst` 上。`lst` 和 `lst2` 都必须是排序了的。元素将从 `lst2` 中移除，在 `merge` 之后 `lst2` 将是空的。第一个版本使用 `<` 操作符；第二个版本使用给定的比较操作。 |
| `lst.remove(val)` 、`lst.remove_if(pred)`   | 使用 `erase` 移除每一个 `==` 给定值或者使得谓词为真的元素。  |
| `lst.reverse()`                             | 反转 `lst` 中的元素顺序。                                    |
| `lst.sort`，`lst.sort(comp)`                | 对` lst` 中的元素进行排序，第一个函数使用 `<` 操作符，第二个使用给定的比较操作。 |
| `lst.unique()` 、`lst.unique(pred)`         | 调用 `erase` 移除相邻相等的元素值，第一个版本使用 `==`；第二个版本使用谓词。 |

注意：

- 链表版本的 `remove` 会真的执行移除操作，链表版本的 `unique` 会移除第二个及之后的重复元素。
- 链表 `merge` 函数会销毁给定链表，将其元素从参数中移除合并到调用者链表上。在 `merge` 之后所有的元素都在同一个链表上。

### `splice` 成员

`list `和 `forward_list` 的 `splice` 函数可以进行容器合并。共有两种形式：`splice(args)` ，`splice_after(args)`：

| 参数              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `(p, list2)`      | 将 `lst2` 中的元素移动到 `p` 迭代器所表示为位置前，并从 `lst2` 中移除元素。如果是 `splice_after`：则拼接到 `p` 之后，`lst2` 的类型必须与 `list` 和 `forward_list` 的类型相同，而且不能与调用者是同一个对象。 |
| `(p, lst2, p2)`   | `p2` 是` lst2` 中的有效迭代器，将 `p2` 所表示的元素移动到 `list` 中，或者将 `p2` 后面的那个对象移动到 `forward_list` 中，`lst2` 可以与 `list` 或者 `forward_list` 是相同的对象。 |
| `(p, lst2, b, e)` | 将 `lst2` 中的迭代器 `b` 和 `e` 所表示的范围中的元素移动到 `list` 或 `forward_list` 中，元素会从 `lst2` 中删除。`lst2` 与 `list` 或者 `forward_list` 可以是相同的对象，但 `p` 不能表示 `b` 和 `e` 范围内的元素。 |













