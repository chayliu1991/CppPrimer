.. contents::
   :depth: 3
..

关联容器
========

-  关联容器和顺序容器的不同：关联容器中的元素时按照关键字来保存和访问的。
-  关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是
   ``map`` 和 ``set``\ 。

**关联容器类型**\ ：

====================== =========================================
容器类型               解释
====================== =========================================
按顺序存储            
``map``                关键数组：保存\ ``关键字-值``\ 对
``set``                关键字即值，即只保存关键字的容器
``multimap``           支持同一个键多次出现的\ ``map``
``multiset``           支持同一个键多次出现的\ ``set``
无序集合              
``unordered_map``      用哈希函数组织的\ ``map``
``unordered_set``      用哈希函数组织的\ ``set``
``unordered_multimap`` 哈希组织的\ ``map``\ ，关键字可以重复出现
``unordered_multiset`` 哈希组织的\ ``set``\ ，关键字可以重复出现
====================== =========================================

使用关联容器
------------

使用map
~~~~~~~

``map`` 类型经常被称为是关联数组。

::

   map<string, size_t> word_count; 
   string word;
   while (cin >> word)
       ++word_count[word]; 
   for (const auto &w : word_count) 
       cout << w.first << " occurs " << w.second
           << ((w.second > 1) ? " times" : " time") << endl;

``map`` 中是 ``pair`` 类型，\ ``pair`` 是一个模板类型，保存两个名为
``first`` 和 ``second`` 的公有数据成员。\ ``map`` 所使用的 ``pair`` 用
``first`` 成员保存关键字，用 ``second``\ 成员保存对应的值。

使用set
~~~~~~~

``set`` 就是键的集合，\ ``set`` 最常用于查询一个值是否在集合中。

::

   set<string> exclude = {"The", "But", "And", "Or", "An", "A"};

为了检查键是否存在，可以调用 ``set`` 的 ``find`` 函数：

::

   if (exclude.find(word) == exclude.end())

关联容器概述
------------

-  关联容器不支持顺序容器特有的与位置相关的操作，如 ``push_front`` 或
   ``back`` 。
-  关联容器不支持以一个元素值和个数的构造函数和插入操作。
-  关联容器的迭代器是双向迭代器。

定义关联容器
~~~~~~~~~~~~

当定义 ``map`` 时，需要指定键和值的类型 。当定义 ``set``
时需要指定键的类型。

-  每个关联容器都定义了一个默认构造函数，其将创建一个指定类型的空容器。
-  可以将关联容器初始化为另外一个相同类型容器的副本，或者以一系列值进行初始化，只要这些值可以转为容器的类型。
-  在新标准下可以用列表初始化元素。

::

   map<string, size_t> word_count;   //@ 空的容器
   set<string> exclude = {"the", "but", "and", "or", "an"};    
   map<string, string> authors = { {"Joyce", "James"}, {"Austen", "Jane"} };

当初始化 ``map`` 时，必须同时提供 ``key`` 和
``value``\ 。我们将键-值对放在大括弧中如：\ ``{key, value}``
用于表示这两个值共同构成 ``map`` 中的一个元素。

-  ``map`` 和 ``key`` 中的键必须是唯一的；对于一个给定的 ``key``
   只能有唯一元素与之对应。

-  ``multimap`` 和 ``multiset``
   容器没有类似的限制；相同的键可以有多个元素与之对应。

关键字类型的要求
~~~~~~~~~~~~~~~~

对于有序容器 (``map``\ ，\ ``multimap``\ ，\ ``set`` 和 ``multiset``
)，关键字类型必须定义元素比较的方法。默认是 ``<``\ 。

如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。

::

   bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs) {
       return lhs.isbn() < rhs.isbn();
   }

   multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);

-  当用 ``decltype`` 来表示一个函数指针时，必须提供 ``*``
   来表示我们确实需要的函数的指针，这是由于 ``decltype``
   推断出来的是函数的真实类型。
-  当将 ``compareIsbn``
   指针作为构造函数实参时，可以直接使用其名字，而不必使用
   ``&compareIsbn``
   的形式，这是由于用于参数的函数名字会隐式转为函数指针。

pair类型
~~~~~~~~

-  在 ``<utility>`` 头文件中定义。
-  一个 ``<pair>`` 保存两个数据成员，两个类型不要求一样。
-  ``pair`` 的数据成员是 ``public`` 的。这两个成员的名字是 ``first`` 和
   ``second``\ ，通过成员访问符就可以访问这两个成员。

``pair`` 的操作：

-  ``pair<T1, T2> p;`` ：\ ``p`` 是一个 ``pair``\ ，其中类型\ ``T1`` 和
   ``T2`` 所表示的是值初始化的。
-  ``pair<T1, T2> p(v1, v2);``\ ： ``p`` 是一个 ``pair``\ ，其中类型
   ``T1`` 和 ``T2`` 所表示的成员分别从 ``v1`` 和 ``v2`` 进行初始化。
-  ``pair<T1, T2> p = {v1, v2};`` ：与 ``p(v1, v2)`` 是相同的。
-  ``make_pair(v1, v2)`` ：从 ``v1`` 和 ``v2`` 中初始化一个 ``pair``
   对象，\ ``pair`` 的类型是通过 ``v1`` 和 ``v2`` 的类型进行推断的。
-  ``p.first`` ：返回 ``p`` 的 ``public`` 数据成员 ``first``\ 。
-  ``p.second`` ：返回 ``p`` 的 ``public`` 数据成员 ``second``\ 。
-  ``p1 relop p2`` ：关系操作符 ``relop``\ （\ ``<`` ``>`` ``<=``
   ``>=``\ ），关系操作符被定义为字典序：\ ``p1 < p2`` 的含义与
   ``p1.first < p2.first`` 或者
   ``!(p2.first < p1.first) && p1.second < p2.second`` 是一样的。
-  ``p1 == p2`` 、\ ``p1 != p2`` ：如果两个 ``pair`` 的 ``first`` 和
   ``second`` 数据成员分别相等，那么可以认为这两个 ``pair`` 是相等的。

关联容器的操作
--------------

关联容器额外的类型别名：

-  ``key_type`` ：容器的 ``key`` 的类型。
-  ``mapped_type`` ：每个 ``key`` 对应的值的类型；只有 ``map``
   定义了此类型。
-  ``value_type``\ ： 对于 ``set`` 来说与 ``key_type``
   一样，对于\ ``map`` 来说就是
   ``pair<const key_type, mapped_type>``\ 。

::

   set<string>::value_type v1; //@string
   set<string>::key_type v2; //@ string
   map<string, int>::value_type v3; //@ pair<const string, int>
   map<string, int>::key_type v4; //@ string
   map<string, int>::mapped_type v5; //@ int

关联容器迭代器
~~~~~~~~~~~~~~

解引用一个关联容器迭代器时，会得到一个类型为容器的 ``value_type``
的值的引用。

对于 ``map`` 来说其 ``value_type`` 是一个 ``pair`` 其中 ``first``
保存着一个 ``const`` 的键，而 ``second`` 保存着其对应的值，如：

尽管 ``set`` 类型同时定义了 ``iterator`` 和 ``const_iterator``
类型，两种迭代器类型都是只读的。

::

   set<int> iset = {0,1,2,3,4,5,6,7,8,9};
   set<int>::iterator set_it = iset.begin();
   if (set_it != iset.end()) {
       *set_it = 42;   //@ 错误， set 中的键是只读的
       cout << *set_it << endl;
   }

当我们用迭代器去遍历 ``map``\ ，\ ``multimap``\ ，\ ``set`` 以及
``multiset`` 时，其迭代器产生的元素是按照键的正序排列的。

关联容器的 ``key`` 是 ``const``
的意味着不能将关联容器的迭代器传递给那些需要修改元素或者对容器元素进行重排序的算法。

关联容器中的元素可以通过其键快速被查找到，使用通用搜索算法几乎总是错误的想法。

添加元素
~~~~~~~~

``insert``
成员添加一个元素或一系列元素，如果插入的元素是已经存在的将没有任何效果。

关联容器的 ``insert`` 操作：

-  ``c.insert(v)``\ 、 ``c.emplace(args)`` ：\ ``v``\ 是 ``value_type``
   类型的对象；\ ``args`` 用来构造一个元素。 对于 ``map`` 和
   ``set``\ ，只有元素的关键字不存在 ``c``
   中才插入或构造元素。函数返回一个
   ``pair``\ ，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的
   ``bool`` 值。对于 ``multimap`` 和 ``multiset``
   则会插入范围中的每个元素。
-  ``c.insert(b, e)``\ 、 ``c.insert(il)`` ：\ ``b`` 和 ``e``
   是表示类型为 ``c::value_type`` 的元素范围；\ ``il``
   则是括弧中的一系列值（初始值列表），返回 ``void``\ ；对于 ``map`` 和
   ``set``\ ，将插入不存在于容器中的 ``key`` 关联的元素；对于
   ``multimap`` 和 ``multiset`` 则将插入范围内的每个元素。
-  ``c.insert(p, v)`` 、\ ``c.emplace(p, args)`` ：类似于 ``insert(v)``
   和 ``emplace(args)`` ，但是使用迭代器
   ``p``\ 作为开始搜索插入元素的位置的索引，返回与给定 ``key``
   关联的元素的迭代器。

添加元素到map中
^^^^^^^^^^^^^^^

::

   word_count.insert({word, 1});
   word_count.insert(make_pair(word, 1));
   word_count.insert(pair<string, size_t>(word, 1));
   word_count.insert(map<string, size_t>::value_type(word, 1));

``insert`` 或者 ``emplace``
的返回值将根据容器类型和参数的不同而不同。对于 ``key``
是唯一的容器，\ ``insert`` 和 ``emplace`` 的添加一个元素的版本将返回一个
``pair`` 对象用于判断插入是否发生：

-  ``pair`` 的 ``first`` 成员是一个与给定 ``key`` 关联的元素迭代器。
-  ``second`` 成员是一个 ``bool``
   值用于指示元素是否被插入，或者是否已经存在。如果键已经存在于容器中，那么
   ``insert`` 将不做任何事，并且返回值的 ``bool`` 部分是
   ``false``\ ，如果键不存在，那么元素将被插入并且 ``bool`` 是
   ``true``\ 。

元素到multiset和multimap中
^^^^^^^^^^^^^^^^^^^^^^^^^^

用于 ``multi`` 容器中的 ``key`` 不需要是唯一的，在这些键上 ``insert``
总是插入元素：

::

   multimap<string, string> authors;
   authors.insert({"Brath, John", "Sot-Weed Factor"});
   authors.insert({"Brath, John", "Lost in the Funhouse"});

对于允许多个 ``key`` 的容器，只插入一个元素的 ``insert``
操作将返回新元素的迭代器。

删除元素
~~~~~~~~

关联容器定义了三个版本的 ``erase``\ ，可以用 ``erase``
擦除一个元素（通过传递一个迭代器）或者传递迭代器范围来擦除一个范围内的元素。

-  ``c.erase(k)`` ：从 ``c`` 中移除任何与键 ``k`` 相对应的元素，返回
   ``size_type`` 的值用于表示移除的元素的个数。
-  ``c.erase(p)``\ ： 从 ``c`` 中移除由迭代器 ``p`` 表示的元素，\ ``p``
   必须确实表示 ``c`` 中的一个元素；它不能等于 ``c.end()`` ，返回指向
   ``p`` 的下一个元素的迭代器或者当 ``p`` 为最后一个元素时返回
   ``c.end()`` 。
-  ``c.erase(b, e)`` ：从 ``c`` 中移除由 ``b`` 和 ``e``
   所表示的范围中的元素，返回 ``e``\ 。

map的下标操作
~~~~~~~~~~~~~

``map`` 和 ``unordered_map`` 容器提供了下标操作符和一个对应的 ``at``
函数。

``set`` 类型不支持下标，原因是 ``set``
中没有“值”与键相对应，元素自己就是键，所以“获取与 ``key``
相关的值”是没有意义的。

不能对 ``multimap`` 和 ``unordered_multimap``
进行下标操作，原因是可能有超过一个值与给定的键对应。

-  ``c[k]`` ：返回与键 ``k`` 关联的元素；如果 ``k`` 不在 ``c``
   则添加一个新的值初始化的元素与键 ``k`` 进行关联。
-  ``c.at(k)`` ：检查并访问与键 ``k`` 相关的元素；如果 ``k`` 不在 ``c``
   中则抛出 ``out_of_range`` 异常。

注意：

-  由于下标操作符可能会插入一个元素，我们只能将下标操作用于非 ``const``
   的 ``map`` 之上。
-  ``map`` 的下标运算使用不存在于容器中的
   ``key``\ ，将导致与之关联的元素添加到 ``map`` 中。
-  ``map`` 的下标操作符的返回值类型与通过解引用 ``map``
   的迭代器得到的类型是不一样的。

   -  当对 ``map`` 进行下标运算时，得到一个 ``mapped_type`` 类型的对象。
   -  当解引用 ``map`` 的迭代器时，我们得到一个 ``value_type``
      类型的对象。

访问元素
~~~~~~~~

在一个关联容器中查找元素：

-  ``c.find(k)`` ：返回与键 ``k`` 关联的第一个元素的迭代器，当 ``k``
   不在容器中时返回尾后迭代器。
-  ``c.count(k)`` ：返回与键 ``k``
   关联的元素的个数。对于键是唯一的容器来说，结果总是零或一。
-  ``c.lower_bound(k)`` ：返回键不小于 ``k`` 的第一个元素的迭代器。
-  ``c.upper_bound(k)`` ：返回键大于 ``k`` 的第一个元素的迭代器。
-  ``c.equal_range(k)`` ：返回与键 ``k``
   相关的所有元素的一个迭代器范围的 ``pair``\ ，如果 ``k``
   不在容器中，两个成员都是 ``c.end()``\ 。

注意：

-  ``lower_bound`` 和 ``upper_bound`` 对于无序容器来说是非法的。

在multimap和multiset中查找元素
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

第一种方案：

::

   string search_item("Alain de Botton");
   auto entries = authors.count(search_item);
   auto iter = authors.find(search_item);
   while (entries) {
       cout << iter->second << endl;
       ++iter; 
       --entries; 
   }

第二种方案：

::

   for (auto beg = authors.lower_bound(search_item),
             end = authors.upper_bound(search_item);
        beg != end; ++beg) {
            cout << beg->second << endl;
   }

第三种方案：

::

   for (auto pos = authors.equal_range(search_item);
        pos.first != pos.second; ++pos.first) {
            cout << pos.first->second << endl;
        }

无序容器
--------

有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的
``==`` 运算符。

仅仅在 ``key``
类型天生是不可排序的，或者性能测试显示哈希可以解决问题时才使用无序容器。

除了管理哈希的操作之外，无序容器提供与有序容器一样的操作。

管理bucket
~~~~~~~~~~

无序容器被组织为一系列桶，每个桶中装有零个或多个元素。这些容器使用哈希函数来将元素映射到桶上。

Bucket Interface
^^^^^^^^^^^^^^^^

-  ``c.bucket_count()`` ：查询正在使用的 ``bucket`` 的个数。
-  ``c.max_bucket_count()`` ：这个容器可以容纳的 ``bucket`` 的最大数目。
-  ``c.bucket_size(n)`` ：\ ``n`` 号桶容纳的元素的个数；。
-  ``c.bucket(k)`` ：返回键 ``k`` 可能被找到的桶，类型是
   ``size_type``\ 。

Bucket 迭代器
^^^^^^^^^^^^^

-  ``local_iterator`` ：可以访问 ``bucket`` 中的元素的迭代器类型。
-  ``const_local_iterator`` ：\ ``bucket iterato``\ r 的 ``const``
   版本。
-  ``c.begin(n)`` 、\ ``c.end(n)`` ：\ ``bucket n``
   中的首元素迭代器以及尾后元素迭代器。
-  ``c.cbegin(n)`` 、\ ``c.cend(n)`` :上一条目中的 ``const``
   版本迭代器。

hash策略
^^^^^^^^

-  ``c.load_factor()`` ：每个 ``bucket`` 中的平均元素个数，返回值是
   ``float`` 类型。
-  ``c.max_load_factor()`` ：\ ``c`` 试图维护的桶的平均大小。\ ``c``
   会增加桶的数量以维护 ``load_factor <= max_load_factor``\ ，返回值是
   ``float`` 类型。
-  ``c.rehash(n)`` ：重新调整存储从而 ``bucket_count >= n`` 并且
   ``bucket_count > size/max_load_factor``\ ，如果 ``n``
   大于容器的当前桶的数目（\ ``bucket_count``\ ），\ ``rehash``
   将强制执行，新的桶数目将大于或等于 ``n``\ ，如果 ``n``
   小于容器的当前桶的数目那么这个函数可能没有任何作用。
-  ``c.reserve(n)`` ：重新调整存储从而 ``c`` 可以包含 ``n``
   个元素而不需要 ``rehash``\ 。

无序容器的key类型要求
~~~~~~~~~~~~~~~~~~~~~

标准库同时还定义了一些库类型的 ``hash`` 模板，包括 ``string``
类型和智能指针类型。

除了使用默认的 ``hash``
模板之外，我们还可以提供自己的相等比较函数和计算哈希值的函数。

::

   size_t hasher(const Sales_data &sd)
   {
       return hash<string>()(sd.isbn());
   }
   bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
   {
       return lhs.isbn() == rhs.isbn();
   }

   using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;

   SD_multiset bookstore(42, hasher, eqOp);

上面的代码同时指定了 ``hash`` 函数和相等性比较函数，如果我们的类有自己的
``==`` 操作符，可以仅仅只覆盖哈希函数：

::

   unordered_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);
