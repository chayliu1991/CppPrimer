# 动态内存

## 动态内存与智能指针

为了使得动态内存易于使用并且更加安全，新标准中提供了两个智能指针来管理动态对象：

- `shared_ptr` ：允许多个指针指向同一个对象。
- `unique_ptr` ：则拥有其指向的对象，因而是排外的。

标准库还定义了 `weak_ptr` 表示对 `shared_ptr` 管理的对象的弱引用。

三个类都定义在  `memory`  头文件中。

### shared_ptr类

智能指针是模板类，创建智能指针需要提供指向的对象类型作为模板参数。如：

```
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
```

默认初始化的智能指针表示空指针。

使用智能指针的方式于常规指针是一样的：

- 解引用智能指针返回其指向的对象引用。
- 当将智能指针用于条件语句中，效果相当于测试其是否是空指针。

以下是 `shared_ptr` 和 `unique_ptr` 共有的操作：

- `shared_ptr<T> sp` 、`unique_ptr<T> up` ：指向 `T` 类型的对象的空指针。
- `p` ：将 `p` 用于条件中，如果其指向一个对象将返回 `true`。
- `*p` ：解引用 `p` 从而得到其指向的对象，如果没有 `p` 是空的，结果未定义。
- `p->mem` ：等同于 `(*p).mem`。
- `p.get()` ：返回 `p` 中保存的对象指针。使用时需要当心：返回的指针所指向的对象可能被智能指针删除。
- `swap(p, q)`、 `p.swap(q)` ：交换 `p` 和 `q` 中的指针。

以下是 `shared_ptr` 特有的操作：

- `make_shared<T>(args)` ：返回一个类型为 `T` 的动态对象的智能指针，使用 `args` 进行初始化对象。
- `shared_ptr<T>p(q)` ：`p` 是 `shared_ptr` `q` 的拷贝，将增加 `q` 的引用计数，`q` 中指针必须可以转为 `T*`。
- `p = q` ：`p` 和 `q` 是指向可转换指针的智能指针 `shared_ptr`。减少 `p` 的引用计数，并增加 `q` 的引用计数，当 `p` 的引用计数为 0 时，删除其所指向的动态对象的内存。
- `p.unique()` ：当 `p` 的引用计数是 1 时，返回 `true`，否则返回 `false`。
- `p.use_count()` ：返回 `p` 所指向对象的引用计数，可能是一个很慢的操作，主要用于调试目的。

#### make_shared函数

最安全的分配和使用动态内存的方式就是调用库函数 `make_shared`。

- 这个函数分配并初始化动态对象，然后返回一个指向它的 `shared_ptr` 智能指针。
- `make_shared` 是一个模板函数，调用时需要提供需要创建的对象类型。

```
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10, '9');
shared_ptr<int> p5 = make_shared<int>();  //@ 此时 p5 指向的对象将被值初始化
auto p6 = make_shared<vector<string>>(); //@ 分配一个空的 vector<string> 对象
```

#### 拷贝和赋值shared_ptr

当拷贝或赋值 `shared_ptr` 时，会相应更新各自对动态对象的引用计数。

- 当拷贝 `shared_ptr` 时，计数增加，例如：当用于初始化另一个 `shared_ptr` 或者在赋值表达式中处于等号右边，或传递给函数、从函数中返回都会增加其引用计数。

- 当给 `shared_ptr` 赋予新值时，或者 `shared_ptr` 对象本身被销毁时，引用计数就会减少。

当最后一个指向对象的 `shared_ptr` 被销毁时，其指向的对象将自动销毁。销毁对象使用的成员函数是析构函数。

#### 使用动态内存的三种原因

程序在以下三种情况下会使用动态内存：

- 不知道需要多少对象。
- 不知道需要的对象的精确类型。
- 在多个对象之间共享数据。

### 直接管理内存

#### 使用new来动态分配和初始化对象

在堆上分配的对象是不具名的，`new` 没有任何方式可以给其分配的对象取名。相反，`new` 返回一个指向其分配的对象的指针。

```
//@ pi 指向动态分配的不具名的，未初始化的 int 值
int *pi = new int;
//@ ps 指向空字符串（调用默认构造函数得到）
string *ps = new string;
```

默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或复合类型的对象是未定义值。类类型对象将执行默认构造函数进行初始化。

初始化动态分配对象可以使用直接初始化形式：

```
int *pi = new int(1024);
string *ps = new string(10, '9');
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};
```

如果在动态分配的对象后跟随一对空括号或空括弧，对象将是值初始化的。对于内置类型则为 0，对于类类型对象则调用其默认构造函数。如：

```
string *ps1 = new string; 	//@ 默认初始化为空字符串
string *ps = new string(); 	//@ 值初始化为空字符串
int *pi1 = new int; 		//@ *pi1 的值是未初始化的
int *pi2 = new int(); 		//@ *pi2 的值是 0
```

有时候可以在等号的右边使用 `auto` ，当使用 `new` 操作符时，而且括号中的只有一个参数时，编译器使用括号中的值类型去推断生成的动态对象的类型。此时将使用传入的参数去初始化动态对象，它们具有一样的值和类型。如：

```
//@ p 指向与 obj 同类型的对象，并且以 obj 为初始值
auto p1 = new auto(obj);
//@ 以下写法是错误的
auto p2 = new auto{a,b,c};
```

#### 动态分配const对象

```
const int *pci = new const int(1024);
const int *pcs = new const string;
```

所有的常量，包括动态分配的常量都必须进行初始化。

对于定义了默认构造函数的类类型的动态对象可以调用其默认构造函数进行隐式初始化，所以可以不用提供初始值。

由于分配的对象是 `const` 的，所以返回的指针亦是指向 `const` 的对象。

#### 内存耗尽

当内存耗尽时，`new` 操作符会抛出 `bad_alloc` 异常。

可以使用定位 `new` 来避免抛出异常，这种新的表达式可以传递额外的参数给 `new`。如：

```
int *p1 = new int; //@ 失败时抛出 std::bad_alloc
int *p2 = new (nothrow) int; //@ 失败时返回空指针
```

这里传递给 `new` 一个标准库中的对象` nothrow`，这个对象定义在 `new` 头文件中。`nothrow` 对象告诉 `new` 一定不要抛出任何异常，如果无法分配内存时就返回空指针。

#### 释放动态内存

传递给 `delete` 的指针必须指向动态分配内存或者是空指针。删除一个不是由 `new` 分配的内存指针，或者删除一个指针两次，结果将是未定义的。

#### 管理动态内存是易错的

用 `new` 和 `delete` 来管理内存有三个易错的地方：

- 忘记 `delete` 内存。
- 使用已经释放掉的对象。
- 同一块内存释放两次。

通过在任何情况下都使用智能指针可以避免以上的错误，智能指针只有在没有其它智能指针仍然在指向这块动态内存时，才会销毁这块内存。

当删除一个指针时，指针将变得无效。尽管指针已经无效了，在很多机器上指针依然保有那个已经被释放的内存的地址。此时指针已经变成了悬挂指针，即一个指向不存在的对象的指针。

### shared_ptr和new结合使用

当不初始化智能指针，其将被初始化为空指针。如果将智能指针初始化为一个从 `new` 返回的指针，那么此智能指针将接管这块动态内存。如：

```
shared_ptr<double> p1;
shared_ptr<int> p2(new int(42));
```

其它的定义和改变 `shared_ptr` 的方式：

- `shared_ptr<T> p(q);` ：`p` 将管理由内置指针 `q` 所指向的对象，`q` 必须指向由 `new` 分配的的内存，并且可以转为 `T*`。
- `shared_ptr<T> p(u);` ：`p` 接管 `unique_ptr` `u` 的对象所有权，并使得 `u` 为空指针。
- `shared_ptr<T> p(q, d);`： `p` 接管指针 `q` 所指向的对象所有权，`p` 将使用可调用对象 `d` 替换 `delete` 来释放 `q` 所指向的对象。
- `shared_ptr<T> p(p2, d);` ：`p` 是 `shared_ptr` `p2` 的拷贝，增加引用计数，但是 `p` 用可调用对象 `d` 代替 `delete` 来释放内存。
- `p.reset()`、 `p.reset(q)` 、`p.reset(q, d)` ：如果 `p` 是指向对象的唯一指针，`reset` 将会释放 `p` 所指向的对象。如果提供了额外的内置指针 `q` ，将在之后使得 `p` 指向 `q`，否则将使 `p` 变为空指针。如果提供了可调用对象 `d`，将调用 `d` 而不是 `delete` 来释放内存。

以上以内置指针作为参数的构造函数是 `explicit` 的，因而，不能隐式将内置指针转为智能指针。我们必须使用直接初始化的形式初始化智能指针。

#### 不要混合使用内置指针和智能指针

`shared_ptr` 只能与其它拷贝自己的 `shared_ptr` 配合使用。

如果混合使用内置指针，将导致在智能指针已经释放掉了内存，而指针并不知道这种情况，结果将导致指针变为悬挂指针。

一旦将 `shared_ptr` 与内置指针绑定，这个智能指针将获取内存的所有权，从而，不应该再继续使用内置指针来访问那块内存了。如：

```
void process(shared_ptr<int> ptr)
{
    //@ ptr 将销毁其指向的对象
}
int *x = new int(1024);
process(x);
int j = *x; //@ 未定义的，x 是悬挂指针
```

使用内置指针访问智能指针所拥有的对象是很危险的，因为我们不知道对象将在何时被销毁。

不要使用 `shared_ptr.get()` 得到的指针用于初始化或者赋值给另外一个智能指针。

### 智能指针和异常

智能指针可以保证即使是在函数异常退出地情况下依然会正确释放不再使用地内存。

而内置指针则不做任何事情，由于在函数外部根本无法访问这块内存，从而就造成了内存泄漏。

```
void f()
{
    shared_ptr<int> sp(new int(42)); //@ 即使发生异常亦能正确释放
}
void f2()
{
    int *ip = new int(42);
    delete ip; //@ 发生异常将无法回收其内存
}
```

智能指针只有被恰当的使用才能发出作用，以下是一些约定：

- 不要使用相同的内置指针去初始化超过一个智能指针。
- 不要使用删除 `get` 函数返回的指针。
- 不要用 `get` 函数返回指针去初始化或 `reset` 别的智能指针。
- 当使用 `get` 函数返回的指针时，应当记住当最后一个智能指针销毁时，这个指针会变得无效。
- 使用智能指针管理资源而不是内存时，记得传递一个删除器过去。

### unique_ptr

`unique_ptr` 具有其指向的对象的所有权。不似 `shared_ptr` ，只有一个 `unique_ptr` 指向一个对象，其将独占对象。对象将在 `unique_ptr` 销毁时被释放。

以下是 `unique_ptr` 特有的操作：

- `unique_ptr<T> u1`、 `unique_ptr<T, D> u2` ：定义两个 `unique_ptr` 空指针，它们可以指向类型为 `T` 的对象。`u1` 使用 `delete` 来释放指针，`u2` 使用类型为 `D` 的可调用对象进行释放。
- `unique_ptr<T, D> u(d)` ：定义 `unique_ptr` 空指针，使用类型为 `D` 的可调用对象 `d` 进行对象释放。
- `u = nullptr`： 删除 `u` 所指向的对象，并使其称为空指针（只接收 `nullptr` 类型）。
- `u.release()` ：交出 `u` 所指向对象的控制权，返回 `p` 所指向对象的内置指针，并使得 `u` 为空指针。
- `u.reset()`： 删除 `u` 所指向的对象。
- `u.reset(q)`、 `u.reset(nullptr)` ：删除 `u` 所指向的对象，并使得 `u` 指向内置指针所指向的对象，否则使得 `u` 为空指针。

`unique_ptr` 没有类似于 `make_shared` 的函数，相反，我们通常直接将 `unique_ptr` 直接与 `new` 返回的内置指针绑定。

- `shared_ptr` 一样，只能使用直接初始化对其进行初始化，而不能直接用内置指针对智能指针进行等号初始化。
- 因为 `unique_ptr` 拥有其指向的对象，所以，`unique_ptr` 不支持拷贝和赋值。
- 调用 `release` 会切断`unique_ptr` 和对象之间的关系，返回的指针通常用于初始化或赋值另外一个智能指针。这样对象所有权就从一个智能指针转移到了另外一个智能指针，然而，如果我们不使用另外一个智能指针来接收这个指针，将由程序员来管理这个资源。

#### 传递和返回unique_ptr

不能拷贝 `unique_ptr` 的原则有一个例外就是可以拷贝或赋值一个即将销毁的 `unique_ptr`，在新标准中这叫移动：

```
unique_ptr<int> clone(int p) {
    return unique_ptr<int>(new int(p));
}
unique_ptr<int> clone(int p) {
    unique_ptr<int> ret(new int(p));
    return ret;
}
```

### weak_ptr

`weak_ptr` 是一种不控制其指向的对象的生命周期的智能指针，相反它指向 `shared_ptr` 管理的对象。

将 `weak_ptr` 绑定到 `shared_ptr` 并不会改变其引用计数。当最后一个 `shared_ptr` 被销毁时，其管理的对象依然会被释放，即使 `weak_ptr` 依然指向这个对象。因此，称之为弱指针。

以下是 `weak_ptr` 的常用操作：

- `weak_ptr<T> w` ：创建 `weak_ptr` 的空指针，其指向 `T` 类型对象。
- `weak_ptr<T> w(sp)` ：创建指向与 `shared_ptr` `sp` 所指向相同对象的 `weak_ptr` ，`T` 必须与 `sp`所指向对象的类型可以相互转换。
- `w = p`： `p` 可以是 `shared_ptr` 或者 `weak_ptr` ，赋值后 `w` 指向与 `p` 一样的对象。
- `w.reset()` ：使得 `w` 为空指针。
- `w.use_count()` ：返回指向同一个对象的 `shared_ptr` 的个数。
- `w.expired()` ：如果没有 `shared_ptr` 指向对象时返回 `true`，否则返回 `false`。
- `w.lock()` ：如果已经过期，则返回一个空的 `shared_ptr` ，否则返回指向该对象的 `shared_ptr`。

使用 `weak_ptr` ，可以在不影响其指向的对象的生命周期的情况下，安全的访问该对象。

## 动态数组

### new和数组

可以用一个类型别名来动态分配数组，虽然没有用到方括号，但依然是数组形式的 `new[]`。如：

```
typedef int arrT[42];
int *p = new arrT;
delete [] p;  //@ 即使使用了别名，其释放时依然需要方括号
```

当用 `new` 分配数组时，返回的并不是数组类型，而是指向首元素的指针：

- 不能调用 `begin` 和 `end` 标准函数。
- 不能对动态数组使用范围 `for`。

#### 初始化动态分配的数组

通常由 `new` 分配的对象，不论是单个对象还是数组，都是默认初始化的。可以在分配数组后加上括号使其进行值初始化，如：

```
int *pia = new int[10]; //@ 全部是未定义值
int *pia2 = new int[10](); //@ 值初始化为 0
```

在新标准下可以使用括弧中的值对动态分配的数组进行列初始化。如：

```
int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};
```

如果给的值比数组的长度小，其余的元素将被值初始化。如果多于数组长度，则无法编译通过。

动态创建空数组是合法的，当用 0 作为数组长度而执行 `new` 操作时，返回的合法的非 0 指针。这个指针类似于尾后指针，其可以与其它指针进行比较、可以加减 0、可以减去自己产生 0，但是不能用此指针进行解引用。

#### 释放动态数组

与释放单个对象不一样的是，释放动态数组必须加上 `[]` 来指示当前释放的是数组。如：

```
delete p; //@ p 必须指向一个动态分配的对象或者是空指针
delete [] pa; //@ pa 必须指向一个动态分配的数组或者是空指针 
```

- 数组中元素以相反的顺序进行析构，即第一个元素最后析构。当所有元素都析构之后，整个内存被回收。
- 如果在删除数组时没有提供方括号，或者在删除对象时提供了方括号，那么行为将是未定义的。

#### 智能指针和动态数组

标准库提供了数组版本的 `unique_ptr` 来管理动态数组的内存。

```
unique_ptr<int[]> up(new int[10]);
up.release();
```

当 `unique_ptr` 指向数组时，不能调用箭头或点号进行成员访问。毕竟，它指向的是一个数组而不是单个对象。另一方面，可以使用此指针进行下标操作来访问数组中的元素。如：

```
for (size_t i = 0; i != 10; ++i)
    up[i] = i;
```

指向数组的 `unique_ptr` 特有的操作：

- `unique_ptr<T[]>u `：`u` 可以指向一个动态分配的数组，元素类型为 `T`。
- `unique_ptr<T[]> u(p)` ：`u` 指向动态分配的数组，此数组由内置指针 `p` 指向。
- `u[i]`: 返回位置 `i` 处的元素， `u` 必须是指向数组。

`shared_ptr` 没有提供直接管理动态数组的支持，如果想要使用 `shared_ptr` 就必须得自己提供删除器

```
shared_ptr<int> sp(new int[10], [](int *p){ delete[] p; });
sp.reset();
```

### allocator类

在 `<memory>` 头文件中定义了 `allocator` 类，其可以将分配和构建分开。它提供类型识别的分配未构建的内存。

以下是 `allocator` 类支持的操作：

- `allocator<T> a;` ：定义一个可以分配 `T` 类型内存的 `allocator` 对象 `a`。
- `a.allocate(n)` ：分配足够容纳 `n` 个未初始化的 ` T` 类型对象的内存。
- `a.deallocate(p, n)` ：释放 `p` 所指向的内存，其中 `p` 的指针类型必须是 `T*`，并且必须是之前由 `allocate` 分配的内存，`n` 必须是当时调用时传递的尺寸。所有这些已经构建过的对象都必须在调用此函数之前先被调用 `destroy` 函数进行析构。
- `a.construct(p, args)` ：`p` 必须是指向类型 T 的裸内存的指针，`args` 则被传递给 `T` 类型的构造函数，`args` 必须符合其中一个构造函数的原型，这个构造函数将被用于构建 `T` 类型对象。
- `a.destroy(p)` ：在 `p` 指向的对象上进行析构，其中 `p` 必须是 `T*` 类型的。

`allocator` 是模板类，所以在定义 `allocator` 时需要提供对象类型作为模板参数。如：

```
allocator<string> alloc;
auto const p = alloc.allocate(n); //@ 分配 n 个未构建的字符串
```

新标准中允许调用 `construct` 成员函数来在指定位置构建对象：

```
auto q = p;
alloc.construct(q++); //@ 构建空字符串
alloc.construct(q++, 10, 'c'); //@ q 是 cccccccccc
alloc.construct(q++, "hi"); //@ q 是 hi
```

必须在构建之后才能使用对象，使用没有构建的对象是一种错误。当使用完毕后必须调用 `destroy` 进行析构，`destroy` 函数以指向对象的指针为参数，调用其析构函数。如：

```
while (q != p)
    alloc.destroy(--q);
```

只能对已经构建的对象进行析构，如果对未构建过的对象进行析构结果将是未定义的。已经被析构的对象占用的内存，可以被用于别的对象，或者将其返回给系统。

通过 `deallocate` 来释放整个内存，如：

```
alloc.deallocate(p, n);
```

传递给 `deallocate` 的指针一定不能是空指针，且必须指向由 `allocate` 分配内存所返回的指针，并且 `n` 必须与传递给 `allocate` 进行分配时一致。

#### 复制和填充未初始化的内存

以下这些函数将在目的地构建元素，而不是给它们赋值：

- `uninitialized_copy(b, e, b2)` ：从由迭代器 `b` 和 `e` 指示的元素范围拷贝到由 `b2` 迭代器所指示裸内存。`b2` 必须是由 `allocate` 分配的，并且足够容纳拷贝进来的数据。
- `uninitialized_copy_n(b, n, b2)` ：从迭代器 `b` 开始拷贝 `n` 个值到迭代器 `b2` 所指示的裸内存中。限制与上面一致。
- `uninitialized_fill(b, e, t)` ：在有迭代器 `b` 和 `e` 指示的范围内，填充 `t` 的拷贝。
- `uninitialized_full_n(b, n, t)` ：在从迭代器 `b` 开始 `n` 个元素的裸内存上填充 `t` 的拷贝；。

与 `copy` 不同的是以上 `uninitialized_copy` 是在目的地进行构建而非赋值，与 `copy` 一样，它也返回递增后的目的地迭代器。



`









