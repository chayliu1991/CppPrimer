.. contents::
   :depth: 3
..

顺序容器
========

顺序容器概述
------------

顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

顺序容器类型
~~~~~~~~~~~~

================
===================================================================================
容器类型         介绍
================
===================================================================================
``vector``       可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
``deque``        双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。
``list``         双向链表。只支持双向顺序访问。在\ ``list``\ 中任何位置进行插入/删除操作速度都很快。
``forward_list`` 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。
``array``        固定大小数组。支持快速随机访问。不能添加或者删除元素。
``string``       与\ ``vector``\ 相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。
================
===================================================================================

-  除了固定大小的 ``array``\ 外，其他容器都提供高效、灵活的内存管理。
-  ``forward_list`` 和 ``array`` 是新C++标准增加的类型。
-  新标准库的容器比旧版的快得多。

决定使用哪个顺序容器
~~~~~~~~~~~~~~~~~~~~

-  通常使用 ``vector`` 是最好的选择，除非你有很好的理由选择其他容器。
-  如果程序有许多小的元素并且对空间消耗很敏感，不要使用 ``list`` 和
   ``forward_list``\ 。
-  需要随机访问，使用 ``vector`` 或 ``deque``\ 。
-  需要在容器中间部分进行快速插入和删除，使用 ``list`` 或
   ``forward_list``\ 。
-  如果程序需要是首部和尾部插入或删除元素，而不是中间部分，使用
   ``deque``\ 。

容器库概述
----------

类型别名
~~~~~~~~

-  ``iterator`` ：此容器类型的迭代器类型。
-  ``const_iterator``\ ：可以读取元素但不能修改元素的迭代器类型。
-  ``size_type``\ ：无符号整数类型，足够保存此种容器类型最大可能的大小。
-  ``difference_type``\ ：
   带符号整数类型，足够保存两个迭代器之间的距离。
-  ``value_type`` ：元素类型。
-  ``reference``\ ： 元素的左值类型；和\ ``value_type &``\ 含义相同。
-  ``const_reference``\ ：元素的\ ``const``\ 左值类型，即\ ``const value_type &``\ 。

构造函数
~~~~~~~~

-  ``C c;``\ ：默认构造函数，构造空容器。
-  ``C c1(c2);``\ 或\ ``C c1 = c2;``\ ：构造\ ``c2``\ 的拷贝\ ``c1`` 。
-  ``C c(b, e)``
   ：构造\ ``c``\ ，将迭代器\ ``b``\ 和\ ``e``\ 指定范围内的所有元素拷贝到\ ``c``\ 。
-  ``C c(a, b, c...)`` ： 列表初始化\ ``c``\ 。
-  ``C c(n)``\ ：只支持顺序容器，且不包括\ ``array``\ ，包含\ ``n``\ 个元素，这些元素进行了值初始化。
-  ``C c(n, t)``\ ：包含\ ``n``\ 个初始值为\ ``t``\ 的元素。

注意：

-  只有顺序容器的构造函数才接受大小参数，关联容器并不支持。
-  ``array`` 具有固定大小，和其他容器不同，默认构造的 ``array``
   是非空的。
-  直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。
-  使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。

迭代器
~~~~~~

-  迭代器范围：\ ``begin``\ 到\ ``end``\ ，即第一个元素到最后一个元素的后面一个位置。
-  左闭合区间：\ ``[begin, end)``
-  左闭合范围蕴含的编程设定：

   -  如果 ``begin`` 和 ``end`` 相等，则范围为空。
   -  如果二者不等，则范围至少包含一个元素，且 ``begin``
      指向该范围中的第一个元素。
   -  可以对 ``begin`` 递增若干次，使得 ``begin == end``\ 。

begin和end成员
~~~~~~~~~~~~~~

获取迭代器
^^^^^^^^^^

-  ``c.begin(), c.end()``\ ：返回指向 ``c``
   的首元素和尾元素之后位置的迭代器。
-  ``c.cbegin(), c.cend()``\ ：返回 ``const_iterator``\ 。

注意：

-  以\ ``c``\ 开头的版本是 C++11 新标准引入的
-  当不需要写访问时，应该使用 ``cbegin`` 和 ``cend``\ 。

反向容器的额外成员
^^^^^^^^^^^^^^^^^^

-  ``reverse_iterator``\ ：按逆序寻址元素的迭代器。
-  ``const_reverse_iterator``\ ：不能修改元素的逆序迭代器。
-  ``c.rbegin(), c.rend()``\ ：返回指向 ``c``
   的尾元素和首元素之前位置的迭代器。
-  ``c.crbegin(), c.crend()``\ ：返回 ``const_reverse_iterator``\ 。

定义和初始化容器
~~~~~~~~~~~~~~~~

每个容器类型都定义了默认构造函数:

-  除了 ``array``\ ，其它容器的默认构造函数都创建一个空的容器。
-  除了 ``array`` 之外，其它的容器可以接收一个 ``size``
   的参数，将初始化为有 ``size`` 个元素被值初始化的容器。

初始化容器作为另外一个容器的副本
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

有两种方式可以将一个容器初始化为别的容器的副本：

-  调用拷贝构造函数。
-  除 array 之外拷贝由一对迭代器表示元素范围。

如果通过拷贝构造函数那么容器和元素的类型都必须一样。如果通过迭代器则没有这样的要求，只要元素类型之间是可以转换的。

::

   list<string> authors = {"Milton", "Shakespeare","Austen"};
   vector<const char*> articles = {"a","an","the"};

   list<string> list2(authors);
   deque<string> authList(authors); //@ 错误：容器类型不匹配
   vector<string> words(articles); //@ 错误：元素类型不匹配

   //@ 将 const char* 转为 string
   forward_list<string> words(articles.begin(), articles.end());

列表初始化
^^^^^^^^^^

在新标准下，可以使用列表初始化一个容器。

列表初始化会指定容器中的每个元素的值。除了 ``array``
之外，初始化列表同时暗含了容器的大小：容器大小与元素的初始化列表中的个数一样多。

顺序容器指定大小的构造函数
^^^^^^^^^^^^^^^^^^^^^^^^^^

顺序容器（除了 ``array``
之外）还可以指定大小和可选的元素初始值。如果没有提供元素初始值，那么将创建一个值初始化的容器。如：

::

   vector<int> ivec(10, -1);
   list<string> svec(10, "hi!");
   forward_list<int> ivec(10);
   deque<string> svec(10);

-  如果元素类型是内置类型或者具有默认构造函数的类类型，那么就可以使用接收一个大小的参数的构造函数来构建容器。

-  如果元素类型没有默认构造函数，在初始化时必须同时显式提供元素初始值。

array类是固定尺寸
^^^^^^^^^^^^^^^^^

标准库 ``array`` 类型与内置数组一样，其尺寸是类型的一部分。当定义
``array`` 时除了指定元素类型时，还要指定大小。

使用 ``array`` 类型同时需要指定元素类型和大小：

::

   array<int, 10>::size_type i;
   array<int>::size_type j; //@ 错误：array<int> 不是一个类型

默认构造的 ``array``
不是空的，而是所有的元素都是默认初始化的，这与内置数组的行为一致。

如果想要使用列表初始化 ``array``\ ，提供的初始值必须小于等于 ``array``
的大小。如果初始值更少的话，前面的部分将会被初始值初始化，后面的元素将被值初始化。如果元素类型是类类型，都必须要有默认构造函数。

尽管我们不能拷贝或赋值内置数组，但是标准库 ``array``
是可以拷贝和赋值的。如：

::

   int digs[10] = {0,1,2,3,4,5,6,7,8,9};
   int cpy[10] = digs; //@ 错误：内置数组不能拷贝和赋值
   array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
   array<int, 10> copy = digits;

赋值和swap
~~~~~~~~~~

-  ``c1 = c2`` ：将 ``c1`` 中的元素替换为 ``c2`` 中的元素。
-  ``c1 = {a,b,c...}`` ：将 ``c1`` 中的元素替换为列表中的值（不适用于
   ``array``\ ）。
-  ``a.swap(b)`` ：将 ``a``\ 、\ ``b`` 中的值进行交换。
-  ``swap(a, b)`` ：等于交换 ``a.swap(b)``\ 。
-  ``c.assign(b, e)``\ ：将 ``c`` 中的元素替换成迭代器 ``b`` 和 ``e``
   表示范围中的元素，\ ``b`` 和 ``e`` 不能指向 ``c`` 中的元素。
-  ``c.assign(il)``\ ：将 ``c`` 中的元素替换成初始化列表 ``il``
   中的元素。
-  ``c.assign(n, r)``\ ：将 ``c`` 中的元素替换为 ``n`` 个值是 ``t``
   的元素。

注意：

-  使用非成员版本的 ``swap`` 是一个好习惯。
-  ``assign`` 操作不适用于关联容器和 ``array``\ 。

容器size操作
~~~~~~~~~~~~

-  ``c.size()`` ：\ ``c`` 中元素个数（不适用于 ``forward_list``\ ）。
-  ``c.max_size()`` ：\ ``c`` 所处的容器类型可以容纳的元素的最大数目。
-  ``c.empty()`` ：如果 ``c`` 有元素返回 ``false``\ ，否则返回
   ``true``\ 。

关系操作符
~~~~~~~~~~

-  ``==`` ``!=`` 相等性操作符使用所有容器类型。
-  ``<`` ``<=`` ``>`` ``>=`` 关系操作符（对于无序关联容器不适用）。

左边和右边操作数必须是相同类型的容器，并且其元素类型也必须是一样的。

比较两个容器执行的是两两之间的比较。

如果元素类型不支持需要的比较操作符，那么我们就无法使用容器的对应的操作。

顺序容器操作
------------

给顺序容器添加元素
~~~~~~~~~~~~~~~~~~

除了 ``array``
之外的容器都提供了灵活的内存管理机制。可以动态的添加或移除容器中的元素从而在运行时改变容器的大小。

-  ``c.push_back(t)``\ ：在 ``c`` 尾部创建一个值为 ``t`` 的元素，返回
   ``void``\ 。
-  ``c.emplace_back(args)``\ ：同上。
-  ``c.push_front(t)``\ ：在 ``c`` 头部创建一个值为 ``t`` 的元素，返回
   ``void``\ 。
-  ``c.emplace_front(args)``\ ：同上。
-  ``c.insert(p, t)``\ ：在迭代器 ``p`` 指向的元素之前创建一个值是 ``t``
   的元素，返回指向新元素的迭代器。
-  ``c.emplace(p, args)``\ ：同上
-  ``c.inset(p, n, t)``\ ：在迭代器 ``p`` 指向的元素之前插入n个值为
   ``t`` 的元素，返回指向第一个新元素的迭代器；如果n是0，则返回p。
-  ``c.insert(p, b, e)``\ ：将迭代器 ``b`` 和 ``e`` 范围内的元素，插入到
   ``p`` 指向的元素之前；如果范围为空，则返回 ``p``\ 。
-  ``c.insert(p, il)``\ ：\ ``il``
   是一个花括号包围中的元素值列表，将其插入到 ``p`` 指向的元素之前；如果
   ``il`` 是空，则返回 ``p``\ 。

注意：

-  因为这些操作会改变大小，因此不适用于 ``array``\ 。
-  ``forward_list``\ 有自己专有版本的 ``insert`` 和
   ``emplace``\ 。\ ``forward_list``\ 不支持 ``push_back`` 和
   ``emplace_back``\ 。
-  ``string`` 和 ``vector`` 不支持 ``push_front`` 和
   ``emplace_front``\ 。
-  由于 ``string`` 就是字符的容器，可以用 ``push_back`` 在 ``string``
   的尾部添加字符。
-  当使用对象来初始化容器，或者插入一个对象到容器中时，放入容器中的是那个对象值的拷贝，不是对象本身。

使用insert的返回值
^^^^^^^^^^^^^^^^^^

使用 ``insert`` 的返回值可以重复的插入元素到容器中指定的位置：

::

   list<string> lst;
   auto iter = lst.begin();
   while (cin >> word)
       iter = lst.insert(iter, word);

使用emplace操作
^^^^^^^^^^^^^^^

新标准加入三个新的成员 ``emplace_front`` 、 ``emplace`` 和
``emplace_back`` ，这三个成员对应于 ``push_front`` 、 ``insert`` 和
``push_back``\ ，只是它们不是拷贝元素而是直接构建。

当我们调用 ``emplace``
成员时，传递给元素类型的构造函数的参数，并以这些参数直接直接构建一个对象放在容器中。

传递给 ``emplace``
函数的参数与元素类型有关。参数必须与元素类型的一个构造函数参数列表匹配。

访问元素
~~~~~~~~

-  ``c.back()``\ ：返回 ``c`` 中尾元素的引用。若 ``c``
   为空，函数行为未定义。
-  ``c.front()``\ ：返回 ``c`` 中头元素的引用。若 ``c``
   为空，函数行为未定义。
-  ``c[n]``\ ：返回 ``c`` 中下标是 ``n`` 的元素的引用，\ ``n``
   是一个无符号整数。若 ``n>=c.size()``\ ，则函数行为未定义。
-  ``c.at(n)``\ ：返回下标为 ``n`` 的元素引用。如果下标越界，则抛出
   ``out_of_range`` 异常。

front和back
^^^^^^^^^^^

-  每个顺序容器都有 ``front`` 成员（包括 ``array``\ ），除了
   ``forward_list`` 之外的顺序容器都有 ``back``
   成员，这些操作分别返回首元素和尾元素的引用。

-  在空的容器中调用 ``front`` 或 ``back``
   或者在使用下标时超出范围，是非常严重的编程错误。

::

   if (!c.empty()) {
       auto val = *c.begin(), val2 = c.front();
       auto last = c.end();
       auto val3 = *(--last);
       auto val4 = c.back();
   }

-  以上程序用两种不同的方式获取容器 ``c`` 的首元素和尾元素。
-  需要注意的 ``end``
   返回的迭代器指向的是一个不存在的元素，在解引用之前需要先递减一。
-  在获取元素之前，需要先检查 ``c`` 是不是空的，如果容器是空的，那么
   ``if`` 内的操作就是未定义的。

访问成员返回的是引用
^^^^^^^^^^^^^^^^^^^^

访问成员返回的是容器中元素的引用：

-  如果容器是 ``const`` 对象，那么返回的引用也是 ``const`` 的。
-  如果容器是非 ``const`` 的，那么引用就是常规引用。

::

   if (!c.empty()) {
       auto &v = c.back();
       v = 1024;
   }

用 ``auto`` 保存返回的引用，必须将 ``auto`` 定义引用类型。

下标操作和安全的随机访问
^^^^^^^^^^^^^^^^^^^^^^^^

-  提供快速随机访问的容器（\ ``string``\ 、\ ``vector``\ 、\ ``deque``
   和 ``array``\ ）同时提供了下标操作。

-  下标操作符用一个索引返回那个位置的元素的引用。索引必须是在安全范围内的（大于等于
   0 并且小于容器的大小）。
-  保证索引是合法的是程序的责任；下标操作不会检查索引是否在范围内。使用超出范围的索引是严重的编程错误，但是这个错误是编译器发现不了的。
-  如果想要保证索引是合法的，可以使用 ``at`` 成员。\ ``at``
   成员的行为与下表操作符类型，但是当索引是不合法的时候，\ ``at`` 将抛出
   ``out_of_range`` 异常。

移除元素
~~~~~~~~

-  ``c.pop_back()``\ ：删除 ``c`` 中尾元素，若 ``c``
   为空，则函数行为未定义。函数返回 ``void``\ 。
-  ``c.pop_front()``\ ：删除 ``c`` 中首元素，若 ``c``
   为空，则函数行为未定义。函数返回 ``void``\ 。
-  ``c.erase(p)``\ ： 删除迭代器 ``p``
   指向的元素，返回一个指向被删除元素之后的元素的迭代器，若 ``p``
   本身是尾后迭代器，则函数行为未定义。
-  ``c.erase(b, e)``\ ： 删除迭代器 ``b`` 和 ``e``
   范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若 ``e``
   本身就是尾后迭代器，则返回尾后迭代器。
-  ``c.clear()``\ ：删除 ``c`` 中所有元素，返回 ``void``\ 。

注意：

-  会改变容器大小，不适用于 ``array``\ 。
-  ``forward_list`` 有特殊版本的 ``erase``\ ，\ ``forward_list`` 不支持
   ``pop_back``\ 。
-  ``vector``\ 和 ``string`` 不支持 ``pop_front``\ 。
-  不要将 ``pop`` 操作用于空的容器。

特定于forward_list的操作
~~~~~~~~~~~~~~~~~~~~~~~~

当我们想要在 ``forward_list``
中添加或移除元素时，我们需要记录两个迭代器，一个用于检查元素值
``curr``\ ，一个是这个元素的前置迭代器 ``prev``\ 。

-  ``lst.before_begin()``\ ：返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用，允许我们在首元素之前添加或删除元素。
-  ``lst.cbefore_begin()``\ ：同上，但是返回的是常量迭代器。
-  ``lst.insert_after(p, t)``\ ：在迭代器 ``p`` 之后插入元素。\ ``t``
   是一个对象。
-  ``lst.insert_after(p, n, t)``\ ：在迭代器 ``p`` 之后插入元素。\ ``t``
   是一个对象，\ ``n`` 是数量。若 ``n`` 是0则函数行为未定义。
-  ``lst.insert_after(p, b, e)``\ ：在迭代器 ``p``
   之后插入元素。由迭代器 ``b`` 和 ``e`` 指定范围。
-  ``lst.insert_after(p, il)``\ ：在迭代器 ``p`` 之后插入元素。由 ``il``
   指定初始化列表。
-  ``emplace_after(p, args)``\ ：使用 ``args`` 在 ``p``
   之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若 ``p``
   为尾后迭代器，则函数行为未定义。
-  ``lst.erase_after(p)``\ ：
   删除p指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若
   ``p`` 指向 ``lst`` 的尾元素或者是一个尾后迭代器，则函数行为未定义。
-  ``lst.erase_after(b, e)``\ ：类似上面，删除对象换成从 ``b`` 到 ``e``
   指定的范围。

resize容器大小
~~~~~~~~~~~~~~

除了\ ``array`` 的容器可以使用 ``resize`` 操作来使得容器更大或更小：

-  如果当前大小比请求的尺寸大的话，元素将从后面开始删除。
-  如果当前大小比新的尺寸小的话，元素将被添加到容器的尾部。

-  ``c.resize(n)``\ ：调整 ``c`` 的大小为 ``n`` 个元素，若
   ``n<c.size()``\ ，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化。
-  ``c.resize(n, t)``\ ：调整 ``c`` 的大小为 ``n``
   个元素，任何新添加的元素都初始化为值 ``t`` 。

容器操作会使得迭代器失效
~~~~~~~~~~~~~~~~~~~~~~~~

改变容器大小的操作将会使得迭代器、引用和指针失效。失效的迭代器、引用和指针将不再指向一个元素。使用失效的迭代器、引用和指针是一个严重的编程错误，这就像使用未初始化的指针引发的问题是一样的。

-  向容器添加元素后：

   -  如果容器是 ``vector`` 或
      ``string``\ ，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。如果没有重新分配，插入位置之前的间接引用将保持有效；在插入点之后的元素的引用将会失效。
   -  对于
      ``deque``\ ，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。
   -  对于 ``list`` 和
      ``forward_list``\ ，指向容器的迭代器、指针和引用依然有效。

-  从一个容器中删除元素后：

   -  对于 ``list`` 和
      ``forward_list``\ ，指向容器其他位置的迭代器、引用和指针仍然有效。
   -  对于\ ``deque``\ ，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除
      ``deque``
      的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是\ ``deque``
      的头元素，这些也不会受影响。
   -  对于 ``vector`` 和
      ``string``\ ，指向被删元素之前的迭代器、引用、指针仍然有效，而尾后迭代器将总是失效。

建议：

-  当使用容器元素的迭代器、引用或者指针，尽可能缩短需要迭代器、引用、指针保持有效的代码的范围。
-  给 ``vector`` 、\ ``string`` 和 ``deque``
   添加或移除元素的循环必须了解的一个事实是迭代器、引用和指针可能会失效。
-  不要在会往 ``deque`` 、\ ``string`` 或 ``vector``
   中插入或删除元素的循环中缓存 ``end()`` 返回的迭代器。

vector对象是如何增长的
----------------------

``vector`` 和 ``string``
在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。

-  ``c.shrink_to_fit()``\ ：将 ``capacity()`` 减少到和 ``size()``
   相同大小。
-  ``c.capacity()``\ ：不重新分配内存空间的话，\ ``c``
   可以保存多少个元素。
-  ``c.reverse(n)``\ ：分配至少能容纳 ``n`` 个元素的内存空间。

注意：

-  ``shrink_to_fit`` 只适用于 ``vector``\ 、\ ``string``\ 和
   ``deque``\ 。
-  ``capacity`` 和 ``reverse`` 只适用于 ``vector`` 和 ``string``\ 。

额外的string 操作
-----------------

构造string的其他方法
~~~~~~~~~~~~~~~~~~~~

-  ``string s(cp, n)``\ ：\ ``s`` 是 ``cp`` 指向的数组中前 ``n``
   个字符的拷贝。
-  ``string s(s2, pos2)``\ ：\ ``s`` 是 ``string s2`` 从下标 ``pos2``
   开始的字符的拷贝。若 ``pos2 > s2.size()``\ ，则构造函数的行为未定义。
-  ``string s(s2, pos2, len2)``\ ：\ ``s`` 是 ``string s2`` 从下标
   ``pos2`` 开始的 ``len2`` 个字符的拷贝。

注意：

-  ``n``,\ ``len2``,\ ``pos2`` 都是无符号值。

substr操作
~~~~~~~~~~

``s.substr(pos, n)``\ ：返回一个 ``string``\ ，包含 ``s`` 中从 ``pos``
开始的 ``n`` 个字符的拷贝。\ ``pos`` 的默认值是0，\ ``n`` 的默认值是
``s.size() - pos``\ ，即拷贝从 ``pos`` 开始的所有字符。

改变string的其他方法
~~~~~~~~~~~~~~~~~~~~

-  ``s.insert(pos, args)``\ ：在 ``pos`` 之前插入 ``args``
   指定的字符。\ ``pos`` 可以使是下标或者迭代器。接受下标的版本返回指向
   ``s`` 的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。
-  ``s.erase(pos, len)``\ ：删除从 ``pos`` 开始的 ``len`` 个字符，如果
   ``len`` 被省略，则删除后面所有字符，返回指向 ``s`` 的引用。
-  ``s.assign(args)``\ ：将 ``s`` 中的字符替换成 ``args``
   指定的字符。返回一个指向 ``s`` 的引用。
-  ``s.append(args)``\ ：将 ``args`` 指定的字符追加到
   ``s``\ ，返回一个指向 ``s`` 的引用。
-  ``s.replace(range, args)``\ ：删除 ``s`` 中范围 ``range``
   中的字符，替换成 ``args`` 指定的字符。返回一个指向 ``s`` 的引用。

string搜索操作
~~~~~~~~~~~~~~

``string`` 类提供了6个不同的搜索函数，每个函数都有4个重载版本。

每个搜索操作都返回一个 ``string::size_type``
值，表示匹配发生位置的下标。如果搜索失败则返回一个名为 ``string::npos``
的 ``static`` 成员（类型是 ``string::size_type``\ ，初始化值是-1，也就是
``string`` 最大的可能大小）。

-  ``s.find(args)``\ ：查找 ``s`` 中 ``args`` 第一次出现的位置。
-  ``s.rfind(args)``\ ：查找 ``s`` 中 ``args`` 最后一次出现的位置。
-  ``s.find_first_of(args)``\ ：在 ``s`` 中查找 ``args``
   中任何一个字符第一次出现的位置。
-  ``s.find_last_of(args)``\ ：在 ``s`` 中查找 ``args``
   中任何一个字符最后一次出现的位置。
-  ``s.find_first_not_of(args)``\ ：在 ``s`` 中查找第一个不在 ``args``
   中的字符。
-  ``s.find_first_not_of(args)``\ ：在 ``s`` 中查找最后一个不在 ``args``
   中的字符。

``args`` 必须是一下的形式之一：

-  ``c, pos``\ ：从 ``s`` 中位置 ``pos`` 开始查找字符 ``c``\ 。\ ``pos``
   默认是0。
-  ``s2, pos``\ ：从 ``s`` 中位置 ``pos`` 开始查找字符串
   ``s``\ 。\ ``pos`` 默认是0。
-  ``cp, pos``\ ：从 ``s`` 中位置 ``pos`` 开始查找指针 ``cp``
   指向的以空字符结尾的C风格字符串。\ ``pos`` 默认是0。
-  ``cp, pos, n``\ ：从 ``s`` 中位置 ``pos`` 开始查找指针 ``cp``
   指向的前 ``n`` 个字符。\ ``pos`` 和 ``n`` 无默认值。

s.compare的几种参数形式
~~~~~~~~~~~~~~~~~~~~~~~

逻辑类似于C标准库的 ``strcmp`` 函数，根据 ``s``
是等于、大于还是小于参数指定的字符串，\ ``s.compare``
返回0、正数或负数。

-  ``s2``\ ：比较 ``s`` 和 ``s2``\ 。
-  ``pos1, n1, s2``\ ：比较 ``s`` 从 ``pos1`` 开始的 ``n1`` 个字符和
   ``s2``\ 。
-  ``pos1, n1, s2, pos2, n2``\ ：比较 ``s`` 从 ``pos1`` 开始的 ``n1``
   个字符和 ``s2``\ 。
-  ``cp`` 比较 ``s`` 和 ``cp`` 指向的以空字符结尾的字符数组。
-  ``pos1, n1, cp``\ ：比较 ``s`` 从 ``pos1`` 开始的 ``n1`` 个字符和
   ``cp`` 指向的以空字符结尾的字符数组。
-  ``pos1, n1, cp, n2``\ ：比较 ``s`` 从 ``pos1`` 开始的 ``n1`` 个字符和
   ``cp`` 指向的地址开始 ``n2`` 个字符。

string和数值转换
~~~~~~~~~~~~~~~~

-  ``to_string(val)`` ：一组重载函数，返回数值 ``val`` 的 ``string``
   表示。\ ``val`` 可以使任何算术类型。对每个浮点类型和 ``int``
   或更大的整型，都有相应版本的
   ``to_string()``\ 。和往常一样，小整型会被提升。
-  ``stoi(s, p, b)`` ：返回 ``s``
   起始子串（表示整数内容）的数值，\ ``p`` 是 ``s``
   中第一个非数值字符的下标，默认是0，\ ``b`` 是转换所用的基数。返回
   ``int``\ 。
-  ``stol(s, p, b)``\ ：返回 ``long``\ 。
-  ``stoul(s, p, b)``\ ：返回 ``unsigned long``\ 。
-  ``stoll(s, p, b)``\ ：返回 ``long long``\ 。
-  ``stoull(s, p, b)``\ ：返回 ``unsigned long long``\ 。
-  ``stof(s, p)``\ ：返回 ``s``
   起始子串（表示浮点数内容）的数值，\ ``p`` 是 ``s``
   中第一个非数值字符的下标，默认是0。返回\ ``float``\ 。
-  ``stod(s, p)``\ ：返回 ``double``\ 。
-  ``stold(s, p)``\ ：返回 ``long double``\ 。

容器适配器
----------

-  适配器是使一事物的行为类似于另一事物的行为的一种机制，例如 ``stack``
   可以使任何一种顺序容器以栈的方式工作。
-  初始化 ``deque<int> deq; stack<int> stk(deq);``
   从\ ``deq``\ 拷贝元素到\ ``stk``\ 。
-  创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器：
   ``stack<string, vector<string> > str_stk;``\ 。

适配器的通用操作和类型
~~~~~~~~~~~~~~~~~~~~~~

-  ``size_type``\ ：一种类型，须以保存当前类型的最大对象的大小。
-  ``value_type``\ ：元素类型。
-  ``container_type``\ ：实现适配器的底层容器类型。
-  ``A a;``\ ：创建一个名为 ``a`` 的空适配器。
-  ``A a(c)``\ ：创建一个名为 ``a`` 的适配器，带有容器 ``c``
   的一个拷贝。
-  关系运算符
   每个适配器都支持所有关系运算符：\ ``==、!=、<、 <=、>、>=``
   这些运算符返回底层容器的比较结果。
-  ``a.empty()``\ ：若 ``a`` 包含任何元素，返回 ``false``;否则返回
   ``true``\ 。
-  ``a.size()``\ ：返回 ``a`` 中的元素数目。
-  ``swap(a, b)``\ ：交换 ``a`` 和 ``b`` 的内容，\ ``a`` 和 ``b``
   必须有相同类型，包括底层容器类型也必须相同
-  ``a.swap(b)``\ ：同上。

stack
~~~~~

-  ``s.pop()``\ ：删除栈顶元素，不返回。
-  ``s.push(item)``\ ：创建一个新元素，压入栈顶，该元素通过拷贝或移动
   ``item`` 而来
-  ``s.emplace(args)``\ ：同上，但元素由 ``args`` 来构造。
-  ``s.top()``\ ：返回栈顶元素，不删除。

注意：

-  定义在 ``stack`` 头文件中。
-  ``stack`` 默认基于 ``deque`` 实现，也可以在 ``list`` 或 ``vector``
   之上实现。

queue和priority_queue
~~~~~~~~~~~~~~~~~~~~~

-  ``q.pop()``\ ：删除队首元素，但不返回。
-  ``q.front()``\ ：返回队首元素的值，不删除。
-  ``q.back()``\ ：返回队尾元素的值，不删除。只适用于 ``queue``
-  ``q.top()``\ ：返回具有最高优先级的元素值，不删除。
-  ``q.push(item)``\ ：在队尾压入一个新元素。
-  ``q.emplace(args)`` ：同上。

注意：

-  定义在 ``queue`` 头文件中。
-  ``queue`` 默认基于 ``deque`` 实现，\ ``priority_queue`` 默认基于
   ``vector`` 实现。
-  ``queue`` 可以在 ``list`` 或 ``vector``
   之上实现，\ ``priority_queue``\ 也可以用 ``deque`` 实现。
