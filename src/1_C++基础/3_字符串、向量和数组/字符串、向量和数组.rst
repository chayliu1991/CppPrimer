.. contents::
   :depth: 3
..

字符串、向量和数组
==================

名称空间的using声明
-------------------

``using`` 声明的格式：

::

   using namespace::name

使用 ``using`` 声明后程序中不再需要名称空间前缀就可以直接访问名字。

-  即便是使用了 ``using``
   声明，也可以用全限定的方式引用名字，确保使用是我们想要的名字。

-  头文件中通常不应该包含 ``using``
   声明，这将会导致所有包含的源文件中都有此 ``using``
   声明，冲突的危险将加大。

标准库类型string
----------------

``string`` 表示可变长度的字符串。\ ``string`` 类型包含在 ``<string>``
头文件中。

``string`` 中的元素是顺序存储的，对于字符串 ``s`` 在范围
``[0, s.size())`` 内满足 ``&*(s.begin() + n) == &*s.begin()+ n``
相等性。这就是说可以将 ``s[0]``
的指针传递给任何期待一个字符串数组头元素指针的函数。

定义和初始化string对象
~~~~~~~~~~~~~~~~~~~~~~

初始化 ``string`` 对象的方式：

=======================
===========================================================
方式                    解释
=======================
===========================================================
``string s1``           默认初始化，\ ``s1``\ 是个空字符串
``string s2(s1)``       ``s2``\ 是\ ``s1``\ 的副本
``string s2 = s1``      等价于\ ``s2(s1)``\ ，\ ``s2``\ 是\ ``s1``\ 的副本
``string s3("value")``  ``s3``\ 是字面值“value”的副本，除了字面值最后的那个空字符外
``string s3 = "value"`` 等价于\ ``s3("value")``\ ，\ ``s3``\ 是字面值“value”的副本
``string s4(n, 'c')``   把\ ``s4``\ 初始化为由连续\ ``n``\ 个字符\ ``c``\ 组成的串
=======================
===========================================================

-  拷贝初始化：使用等号 ``=`` 将一个已有的对象拷贝到正在创建的对象。
-  直接初始化：通过括号给对象赋值。

string对象上的操作
~~~~~~~~~~~~~~~~~~

``string`` 的操作：

============================
============================================================================================================
操作                         解释
============================
============================================================================================================
``os << s``                  将\ ``s``\ 写到输出流\ ``os``\ 当中，返回\ ``os``
``is >> s``                  从\ ``is``\ 中读取字符串赋给\ ``s``\ ，字符串以空白分割，返回\ ``is``
``getline(is, s)``           从\ ``is``\ 中读取一行赋给\ ``s``\ ，返回\ ``is``
``s.empty()``                ``s``\ 为空返回\ ``true``\ ，否则返回\ ``false``
``s.size()``                 返回\ ``s``\ 中字符的个数
``s[n]``                     返回\ ``s``\ 中第\ ``n``\ 个字符的引用，位置\ ``n``\ 从0计起
``s1+s2``                    返回\ ``s1``\ 和\ ``s2``\ 连接后的结果
``s1=s2``                    用\ ``s2``\ 的副本代替\ ``s1``\ 中原来的字符
``s1==s2``                   如果\ ``s1``\ 和\ ``s2``\ 中所含的字符完全一样，则它们相等；\ ``string``\ 对象的相等性判断对字母的大小写敏感
``s1!=s2``                   同上
``<``, ``<=``, ``>``, ``>=`` 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
============================
============================================================================================================

-  string IO：

   -  执行读操作
      ``>>``\ ：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
   -  ``getline``\ ：读取一整行，包括空白符。

-  ``size`` 函数返回的类型是 ``string::size_type`` 而不是
   ``int``\ ，\ ``string::size_type``
   被定义为一种无符号类型并且足够长用以容纳任何字符串的长度。
-  ``string``
   的比较策略是依次比较每一个字符，直到遇到不一样的字符，或者其中一个字符串结束，比较结果是不一致字符在字母表中位置较后的字符串较大。
-  字符串字面值和 ``string`` 是不同的类型，字符串字面量并不是 ``string``
   类型，而是以空字符 ``\0`` 结尾的字符数组。可以将字面量与 ``string``
   字符串相加

处理string对象中的字符
~~~~~~~~~~~~~~~~~~~~~~

``cctype`` 头文件中定义了一组标准函数：

===============
===============================================================================
函数            解释
===============
===============================================================================
``isalnum(c)``  当\ ``c``\ 是字母或数字时为真
``isalpha(c)``  当\ ``c``\ 是字母时为真
``iscntrl(c)``  当\ ``c``\ 是控制字符时为真
``isdigit(c)``  当\ ``c``\ 是数字时为真
``isgraph(c)``  当\ ``c``\ 不是空格但可以打印时为真
``islower(c)``  当\ ``c``\ 是小写字母时为真
``isprint(c)``  当\ ``c``\ 是可打印字符时为真
``ispunct(c)``  当\ ``c``\ 是标点符号时为真
``isspace(c)``  当\ ``c``\ 是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）
``isupper(c)``  当\ ``c``\ 是大写字母时为真
``isxdigit(c)`` 当\ ``c``\ 是十六进制数字时为真
``tolower(c)``  当\ ``c``\ 是大写字母，输出对应的小写字母；否则原样输出\ ``c``
``toupper(c)``  当\ ``c``\ 是小写字母，输出对应的大写字母；否则原样输出\ ``c``
===============
===============================================================================

为了处理 ``string`` 中的字符有三种方法：范围 ``for``
语句、迭代器以及下标运算符。

范围 ``for`` 语句是 C++11 标准中引入的，形如：

::

   for (declaration : expression)
       statement

使用引用直接改变字符串中的字符：

::

   for (auto &c: str){
   }

标准库类型vector
----------------

``vector``
中所有对象的类型都相同，每个对象都有一个索引与之对应并用于访问该对象。

``vector`` 是模板而非类型，由 ``vector`` 生成的类型必须包含 ``vector``
中元素的类型，如: ``vector<int>``\ 。

因为引用不是对象，所以不存在包含引用的 ``vector``\ 。

定义和初始化vector对象
~~~~~~~~~~~~~~~~~~~~~~

=============================
=============================================================================
方法                          解释
=============================
=============================================================================
``vector<T> v1``              ``v1``\ 是一个空\ ``vector``\ ，它潜在的元素是\ ``T``\ 类型的，执行默认初始化
``vector<T> v2(v1)``          ``v2``\ 中包含有\ ``v1``\ 所有元素的副本
``vector<T> v2 = v1``         等价于\ ``v2(v1)``\ ，\ ``v2``\ 中包含\ ``v1``\ 所有元素的副本
``vector<T> v3(n, val)``      ``v3``\ 包含了n个重复的元素，每个元素的值都是\ ``val``
``vector<T> v4(n)``           ``v4``\ 包含了n个重复地执行了值初始化的对象
``vector<T> v5{a, b, c...}``  ``v5``\ 包含了初始值个数的元素，每个元素被赋予相应的初始值
``vector<T> v5={a, b, c...}`` 等价于\ ``v5{a, b, c...}``
=============================
=============================================================================

向vector对象中添加元素
~~~~~~~~~~~~~~~~~~~~~~

``push_back`` 函数可以把一个值添加到 ``vector`` 的尾端。

==============================
==========================================================================
操作                           解释
==============================
==========================================================================
``v.emtpy()``                  如果\ ``v``\ 不含有任何元素，返回真；否则返回假
``v.size()``                   返回\ ``v``\ 中元素的个数
``v.push_back(t)``             向\ ``v``\ 的尾端添加一个值为\ ``t``\ 的元素
``v[n]``                       返回\ ``v``\ 中第\ ``n``\ 个位置上元素的引用
``v1 = v2``                    用\ ``v2``\ 中的元素拷贝替换\ ``v1``\ 中的元素
``v1 = {a,b,c...}``            用列表中元素的拷贝替换\ ``v1``\ 中的元素
``v1 == v2``                   ``v1``\ 和\ ``v2``\ 相等当且仅当它们的元素数量相同且对应位置的元素值都相同
``v1 != v2``                   同上
``<``,\ ``<=``,\ ``>``, ``>=`` 以字典顺序进行比较
==============================
==========================================================================

-  ``size`` 函数返回 ``vector`` 对象中元素的个数，返回值是由 ``vector``
   定义的 ``size_type``
   类型。\ ``vector``\ 对象的类型包含其中元素的类型。

::

   vector<int>::size_type  //@ ok
   vector::size_type       //@ error

-  范围 ``for`` 语句内不应该改变其遍历序列的大小。
-  ``vector``\ 对象（以及\ ``string``\ 对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

迭代器介绍
----------

迭代器是对语言中的指针的一种抽象和模拟，用来间接访问元素。与指针一样，通过迭代器可以从一个元素移动到另一个元素，可以通过解引用返回元素的引用，可以通过箭头符调用其成员函数。

所有标准库容器都可以使用迭代器，但是其中只有少数几种同时支持下标运算符。

使用迭代器
~~~~~~~~~~

定义了迭代器的类型都拥有 ``begin`` 和 ``end`` 两个成员函数：

-  ``begin``\ 函数返回指向第一个元素的迭代器
-  ``end``
   函数返回指向容器“尾元素的下一位置的迭代器，通常被称作尾后迭代器或者简称为尾迭代器。尾后迭代器仅是个标记，表示程序已经处理完了容器中的所有元素。
-  如果容器为空，则\ ``begin`` 和 ``end``
   返回的是同一个迭代器，都是尾后迭代器。

标准容器迭代器的运算符:

================== ========================================
运算符             解释
================== ========================================
``*iter``          返回迭代器\ ``iter``\ 所指向的元素的引用
``iter->mem``      等价于\ ``(*iter).mem``
``++iter``         令\ ``iter``\ 指示容器中的下一个元素
``--iter``         令\ ``iter``\ 指示容器中的上一个元素
``iter1 == iter2`` 判断两个迭代器是否相等
================== ========================================

迭代器类型
~~~~~~~~~~

标准库为每个容器类定义两个迭代器类型：\ ``iterator`` 和
``const_iterator`` 。使用\ ``const_iterator``
迭代器，只能读取容器内元素不能改变。

-  所有的 ``const`` 对象返回的的迭代器都是 ``const_iterator``\ 。
-  非 ``const`` 对象可以通过 ``cbegin`` 和 ``cend`` 成员函数返回
   ``const_iterator``\ 。

任何可能改变容器对象容量的操作，都会使该对象的迭代器失效。

迭代器算术运算
~~~~~~~~~~~~~~

``vector`` 和 ``string`` 迭代器支持的运算：

+-----------------+-----------------------------------------------------+
| 运算符          | 解释                                                |
+=================+=====================================================+
| ``iter + n``    | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者 |
|                 | 指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
+-----------------+-----------------------------------------------------+
| ``iter - n``    | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容 |
|                 | 器内的一个元素，或者指示容器尾元素的下一位置。      |
+-----------------+-----------------------------------------------------+
| ``iter1 += n``  | 迭代器加法的复合赋值语句，将\ ``iter1``\ 加n的结果赋给\ ``iter1`` |
+-----------------+-----------------------------------------------------+
| ``iter1 -= n``  | 迭代器减法的复合赋值语句，将\ ``iter2``\ 减n的加过赋给\ ``iter1`` |
+-----------------+-----------------------------------------------------+
| ``iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代 |
| ``              | 器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
+-----------------+-----------------------------------------------------+
| ``>``\ 、\ ``>=` | 关系运算，只有当两个迭代器都指向同一个容器时才有意义，否则结果是未定义的。当一个迭代器在另一个之前时， |
| `\ 、\ ``<``\ 、\ | 我们说此迭代器较小。                              |
|  ``<=``         |                                                     |
+-----------------+-----------------------------------------------------+

-  ``iter1 - iter2`` 的结果类型是各自容器的
   ``difference_type``\ ，如：\ ``vector<int> difference_type``\ ，这是一个有符号整数类型。

数组
----

数组用于容纳一系列紧靠的无名对象，数组的大小是不可变的。通常使用数组是由于其优于
``vector``
的运行性能。建议除非有充分的理由使用数组，尽可能是在任何场景使用
``vector`` 。

定义和初始化内置数组
~~~~~~~~~~~~~~~~~~~~

数组是一种复合类型，声明形式为\ ``a[d]``\ ，其中 ``a``
是数组名称，\ ``d`` 是数组维度。维度必须是一个常量表达式。

-  在不给定初始值时，数组是默认初始化的，内置类型数组如果定义在函数中默认初始化是未定义值。

-  数组的定义是不允许使用 ``auto`` 关键字对其元素类型进行推断。

-  没有元素为引用的数组。

显式初始化数组元素
^^^^^^^^^^^^^^^^^^

数组可以用列表初始化，如果进行列表初始化时不提供维度，则编译器从初始值列表中推断。

如果指定了维度，则初始列表的个数一定不能超过维度，否则将是编译错误。如果初始值列表长度不足维度数，则剩余的元素将执行值初始化，对于内置类型来说就是都初始化为
0 。如：

::

   int a2[] = {0, 1, 2};   //@ array 的维度是 3
   int a3[5] = {0, 1, 2};  //@ 等价于 a3[] = {0, 1, 2, 0, 0}
   string a4[3] = {"hi", "bye"};   //@ 等价于 a4[] = {"hi", "bye", ""}
   int a5[2] = {0,1,2};    //@ 错误，初始化值的个数超过了数组的维度

可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。

::

   char a1[] = {'C', '+', '+'};        //@ 列表初始化，没有 \0 
   char a2[] = {'C', '+', '+', '\0'};  //@ 列表初始化，显示的添加了 \0 
   char a3[] = "C++";      //@ 自动添加了 \0 
   const char a4[6] = "Daniel";    //@错误，没有空间存放 \0 

不能将数组初始化为另外一个数组，也不能将数组赋值给另外一个数组。

理解复杂数组声明
^^^^^^^^^^^^^^^^

::

   int *ptrs[10]; //@ ptrs 是一个数组，包含 10 个 int* 元素
   int (*Parray)[10]; //@ Parray 是一个指针，指向一个包含 10 个 int 类型的数组
   int (&arrRef)[10]; //@ arrRef 是一个引用，绑定到包含有 10 个 int 类型的数组
   int &refs[10] = /* ? */;    //@ 错误，数组元素不能是引用类型

访问数组元素
~~~~~~~~~~~~

数组下标的类型：\ ``size_t``
，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。\ ``size_t``
定义在头文件 ``cstddef`` 中。

访问数组的数组越界行为同样是未定义行为，在运行时未定义行为可能会正确，可能会在很久之后引起系统崩溃，但绝不会抛出异常。

指针和数组
~~~~~~~~~~

数组和指针的区别：

-  对数组进行 ``sizeof``
   操作得到是整个数组的所占的内存的大小，而对指针的 ``sizeof``
   操作得到的是指针所占内存的大小。

::

   int arr[] = {10,20,30,40,50,60};
   int *ptr = arr;

   cout << sizeof(arr) << endl;   //@ 24
   cout << sizeof(ptr) << endl;   //@ 4(32位计算机)，8(64位计算机)

-  不允许对数组进行直接赋值，但是指针可以，对指针赋值使得指针指向别的位置。

::

   int x = 10;
   arr = &x; //@ 错误
   ptr = &x; //@ 正确，指向 x

-  对指针进行取地址得到是指针的指针，对数组进行取地址得到是包含数组维度的数组指针。

::

   int ** pptr = &ptr;
   int (*parray)[6] = &arr;

-  用数组初始化的字符串常量可以改变其元素，用指针初始化的字符串常量改变其元素将是未定义行为，原因在于前者拷贝了字符串常量，而后者指向的是只读存储字符串常量的只读内存位置。

::

   char amessage[] = "now is the time";
   char *pmessage = "now is the time";

   amessage[0] = 'H';  //@ 正确
   pmessage[0] = 'H';  //@ 错误，未定义的行为

除此之外指针和数组就可以完全替换使用，特别是数组名可以赋值给指针变量，指向数组元素的指针可以用下标访问别的元素。通常，编译器会将数组转为一个指向首元素的指针。如：

::

   int ia[] = {0,1,2,3,4,5,6,7,8,9};
   auto ia2(ia); //@ ia2 是 int*

``decltype`` 关键字不会发生这种转换，直接返回数组类型， ``decltype(ia)``
返回的是数组 ``int[10]``\ 。

指针是语言定义的迭代器
^^^^^^^^^^^^^^^^^^^^^^

事实上迭代器是对指针的模拟和抽象。指针支持自增、自减和算术运算。

指向数组元素的指针中有一个特殊指针即指向数组尾元素下一个位置的指针，这个指针叫尾后指针。通过将索引指定为数组长度得到的就是尾后指针，如：

::

   int *e = &ia[10]; //@ ia 是长度为 10 的 int 数组

上面 ``ia[10]``
是一个不存在的元素，对其唯一允许的操作就是取地址，除此之外的任何操作都是未定义的。尾后指针不能解引用，向后移动亦是非法的。

标准库 begin 和 end 函数
^^^^^^^^^^^^^^^^^^^^^^^^

新标准中在 ``<iterator>`` 头文件中定义了 ``begin`` 和 ``end``
函数用于返回数组的头指针和尾后指针，行为与容器的同名函数一样。

这两个方法以数组为参数。这样就将迭代器和指针统一了，范围 ``for``
以及泛型方法就是利用了这个特点得以以统一的方式对它们进行操作。

指针算术运算
^^^^^^^^^^^^

-  指针支持与整数的加减法，确保结果指针依然指向数组中的元素。

-  指向相同数组的指针间的减法将得到两者之间的距离，结果类型是
   ``ptrdiff_t``
   ，此类型是机器相关的有符号整数，并且保证容纳任何地址差。
-  指针支持关系运算符，然而将其运用于两个不相关的对象指针上结果是未定义的。

指针和下标操作
^^^^^^^^^^^^^^

对数组进行下标操作和对指针进行下标操作的效果是等同的，意味着可以在对指针进行下标操作。

如以下方式都是等同的：

::

   int i = ia[2];
   int *p = ia;

   i = *(p+2);
   i = p[2];

甚至可以像如下代码这样做，将索引指定为负数，只要取出的元素确实存在于数组中。如：

::

   int *p = &ia[2];
   int j = p[-1];
   int k = p[-2];

``vector`` 和 ``string``
的下标要求一定是无符号整数，而数组的下标可以是负数。这是它们之间的重大区别。

C风格字符串
~~~~~~~~~~~

C
风格字符串是将字符串存放在字符数组中，并以空字符结束。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。

C++ 标准支持 C 风格字符串，但是最好不要在 C++
程序中使用它们。对大多数程序来说，使用标准库 ``string`` 要比使用 C
风格字符串更加安全和高效。

风格字符串函数定义在 ``<cstring>`` 头文件中：

==================
=================================================================================================================================
函数               介绍
==================
=================================================================================================================================
``strlen(p)``      返回\ ``p``\ 的长度，空字符不计算在内
``strcmp(p1, p2)`` 比较\ ``p1``\ 和\ ``p2``\ 的相等性。如果\ ``p1==p2``\ ，返回0；如果\ ``p1>p2``\ ，返回一个正值；如果\ ``p1<p2``\ ，返回一个负值。
``strcat(p1, p2)`` 将\ ``p2``\ 附加到\ ``p1``\ 之后，返回\ ``p1``
``strcpy(p1, p2)`` 将\ ``p2``\ 拷贝给\ ``p1``\ ，返回\ ``p1``
==================
=================================================================================================================================

-  C
   风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组，否则行为是未定义的。
-  ``strcat`` 和 ``strcpy``
   都需要程序员保证内存不会溢出，否则行为将是未定义的。
-  ``strlen`` 获取字符串长度，当遇到空字符时停止计数。

提供给旧代码的接口
~~~~~~~~~~~~~~~~~~

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：

-  允许使用以空字符结束的字符数组来初始化 ``string`` 对象或为 ``string``
   对象赋值。
-  在 ``string``
   对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。
-  在 ``string``
   对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。

不能用 ``string``
对象直接初始化指向字符的指针。为了实现该功能，\ ``string``\ 提供了一个名为
``c_str``\ 的成员函数，返回 ``const char*``
类型的指针，指向一个以空字符结束的字符数组，数组的数据和 ``string``
对象一样。

::

   string s("Hello World");    //@ 正确
   char *str = s;  //@  错误，不能使用 string 初始化 char*
   const char *str = s.c_str();    //@ 正确

可以使用数组来初始化 ``vector``
对象，但是需要指明要拷贝区域的首元素地址和尾后地址。

::

   int int_arr[] = {0, 1, 2, 3, 4, 5};
   vector<int> ivec(begin(int_arr), end(int_arr));

在新版本的 C++ 程序中应该尽量使用
``vector``\ 、\ ``string``\ 和迭代器，避免使用内置数组、C
风格字符串和指针。

多维数组
~~~~~~~~

C++
中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。

通常把二维数组的第一个维度称作行，第二个维度称作列。

多维数组初始化的几种方式：

::

   //@ ia 包含3个元素，每个元素都是大小为4的int型数组
   int ia[3][4] =
   {  
       { 0, 1, 2, 3 },   //@ 初始化行0的元素
       { 4, 5, 6, 7 },   //@ 初始化行1的元素
       { 8, 9, 10, 11 }  //@ 初始化行2的元素
   };

   //@ 与上面等价的定义
   int ib[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };

   //@ 每行中未给出的元素被初始化为0
   int ic[3][4] = { { 0 },{ 4 },{ 8 } };

   //@ 显示的初始化行0的元素，其它元素都是0
   int id[3][4] = { 0, 3, 6, 9 };

多维数组的下标引用
^^^^^^^^^^^^^^^^^^

多维数组进行下标引用将得到多种不同类型的元素，具体看给出了多少个下标值。如：

::

   int arr[10][20][30];
   arr[0][0][0];   //@ int
   arr[1][3]; //@ int[30]
   arr[2]; //@ int[20][30]

这同样会影响到指针的类型，指向数组的指针会带上数组的维度。如：

::

   int (*ptrarr)[20][30] = arr;
   int (*ptr2)[30] = arr[0]; //@ 或者 = *arr，但是下标形式更加易于理解
   int *ptr3 = arr[0][0]; //@  或者 = **arr

使用 ``auto`` 和 ``decltype`` 能省略复杂的指针定义。

::

   for (auto p = ia; p != ia + 3; ++p) 
   {
       for (auto q = *p; q != *p + 4; ++q)
           cout << *q << ' ';
       cout << endl;
   }

如果将多维数组运用于范围
``for``\ ，外部循环中的控制变量必须使用引用形式，否则得到的将是指针而不是数组，而指针是不能遍历的。如：

::

   for (auto &row : ia)
       for (auto &col : row)
           //@ do something
