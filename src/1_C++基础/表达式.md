# 表达式

## 基础

表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。

### 基础概念 

操作符有一元操作符和二元操作符以及三元操作符以及函数调用，其中函数调用可以有无限制的操作数。

多个操作符构成的表达式需要理解操作符的优先级和结合性以及在某些情况下表达式依赖于操作数的求值顺序。

当表达式中的操作数不一样时，会将操作数转为相同的类型。如：整型提升，将整数转为浮点数的转换，在赋值表达式中将浮点数转为整数。  

对于类类型，可以定义类自己的操作符含义，使得它们可以跟内置类型一样使用，称为操作符重载。操作符重载不能改变操作符的操作数个数以及优先级和结合性。

### 左值和右值

C++ 的表达式分为右值和左值。   

- 当一个对象被用作右值的时候，用的是对象的值（内容）。
- 当对象被用作左值时，用的是对象的地址。
- 需要右值的地方可以用左值代替，反之则不行。  

最常见的左右值操作符解释：  

- `=` 等号的左操作数必须是左值，并且将赋值后的左操作数作为左值返回。      
- `&` 取地址符需要左值，并且以右值形式返回指针。         
- `*` 解引用和 `[]` 下标操作符都将产生左值。      
- 自增操作符和自减操作符都需要左值作为操作数，前置形式返回左值，后置形式返回右值。     

如果 `decltype` 作用于一个求值结果是左值的表达式，会得到引用类型。

```
int i;
decltype(i) a;   //@ a 是 int
decltype((i)) b; //@ 错误，b 是 int& 必须被初始化
```

### 优先级和结合性   

- 复合表达式指含有两个或多个运算符的表达式。优先级与结合律决定了运算对象的组合方式。
- 括号无视优先级与结合律，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。

### 求值顺序  

大部分的操作符不会要求操作数的求值顺序，可以以任何顺序对操作数进行求值。如：`int i = f1() * f2();` 就能以任何顺序对 `f1` 和 `f2` 函数进行调用。

对于不强制要求操作数顺序的操作符，如果对一个操作数又改变又取值就是错误，通常导致未定义行为。如：

```
int i = 0;
cout << i << " " << ++i << endl;
```

编译器可能先去 `i` 的值在进行 `++i`，也可能先进行 `++i` 再取 `i` 值，或者编译器可以同时运算。三种结果是完全不同的。程序应当避免这样做。

只有 4 个操作符是保证求值顺序的。`&&` 逻辑与、`||` 逻辑或、`?: `条件操作符、`, `逗号操作符。

不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。

## 算术运算符

算术运算符：`+` 一元加，`-` 一元减，`*` 乘号，`/` 除号，`%` 取模，`+` 加号，`-` 减号。

- 所有算数运算符都是左结合的，操作数和结果都是右值。  
- 算数运算符需要注意的是值溢出，分为上溢和下溢。现代计算机的整数表示都是补码，补码溢出时会回绕，上溢之后值变成最小值，下溢则变成最大。
- 取模运算 `%`  与 除法 `/` 舍入方式是一致的，新标准要求舍入方向是向 0 取整，即直接去除小数部分。
- 取模运算 `%` 只能运用于整数类型，模的结果与被除数的符号一致。

```
cout << -9 % 4 << endl;		//@  -1
cout << 9 % -4 << endl;		//@  1
cout << -9 % -4 << endl;	//@  -1
```

## 逻辑和关系操作符

逻辑和关系操作符：`!`逻辑非，`<` 小于号，`>` 大于号，`<=` 小于等于，`>=` 大于等于，`==` 等于，`!=` 不等于，`&&` 逻辑与，`||` 逻辑或。

- 逻辑和关系操作符的操作数是右值，结果是右值，所有这些操作符都返回 `bool` 值。
- 逻辑与运算符 `&&` 和逻辑或运算符 `||` 都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值：
  - 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。
  - 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。

#### 相等测试与 `bool` 字面量

需要注意的是测试算术或指针对象的最好方式是直接在条件语句中测试，而不要让它们与 `bool` 值进行比较，这样会引起意外的结果。如：

```
if (val == true) { /* ... */ }  //@ 只有当 val 为 1 时才会相等
```

`true` 会被整型提升为 `int` 类型，从而 `true` 转为 1，从而变成 `if (val == 1)` 这肯定不是我们想要的。

## 赋值操作符

- 赋值操作符的左操作数必须是可修改的左值，结果是其左操作数，并且是一个左值。
- 当左右类型不一样时，右操作数类型转为左操作数类型。
- C++11 新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。如果提供一个空列表，左操作数将被赋值一个值初始化的值。列表中的值不能执行精度变小的转换。

```
vector<int> vi;     
vi = {0,1,2,3,4,5,6,7,8,9};  

int k;
k = {}; //@ k 等于 0
k = {3.14}; //@ 错误，不允许精度降低
```

- 赋值是右结合的。赋值语句的结果是最右端的操作数的值，整个链上的值都是一样的。多赋值表达式的类型必须与其右边的操作数一致，或者可以互相转换。
- 赋值操作的优先级通常较低，特别是赋值比关系操作优先级还低，所以经常需要用括号将赋值操作括起来。
- 不要混淆相等运算符`==`和赋值运算符`=`。
- 复合赋值运算符包括`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`和`|=`。任意一种复合运算都完全等价于 `a = a op b`。

## 递增和递减运算符

- 自增和自减操作符可用于指针、迭代器和算术类型。
- 这两个运算符都要求操作数是左值。
- 自增和自减有两种形式：前置和后置:
  - 前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。
  - 后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。
  - 后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。C++ 建议：仅在必要使用后置形式。
  - 在某些语句中混用解引用和递增运算符可以使程序更简洁

```
cout << *iter++ << endl;
```

## 成员访问运算符

- 点运算符 `.` 和箭头运算符 `->` 都可以用来访问成员，表达式 `ptr->mem `等价于 `(*ptr).mem`。

- 类或结构对象可以直接用 `.` 点号访问成员，对象指针可用 `->` 箭头访问成员。
- 箭头操作符要求一个指针操作数，并且返回一个左值方能访问其成员。点号操作符当对象是左值是返回左值，当对象是右值时返回右值。

## 条件操作符

- `cond ? expr1 : expr2` 求值顺序是有要求的，当条件为真时，`?` 后的 `expr1` 求值，否则对 `expr2` 求值。
- 要求 `expr1` 和 `expr2` 的结果是相同类型或者可以相互转换。如果两个表达式都是左值，则整个条件操作的结果是左值，否则将是右值。
- 条件操作可以嵌套，但最好不要嵌套多于两层。条件操作是右结合的，意味着多个条件操作符嵌套时将从右边开始分析。
- 由于条件操作符的优先级非常低，所以很多时候必须将条件操作符用括号括起来。

## 位运算符

位操作符：`~` 位取反，`<<` 位左移，`>>` 位右移，`&` 位与，`|` 位或，`^` 位异或。

- 位操作符只能作用于整型操作数，并将整数作为位的集合，位操作符可以操作单个位。
- 在位运算中符号位如何处理并没有明确的规定，所以建议仅将位运算符用于无符号类型的处理。

#### 位移运算符

- 左移运算符 `<<` 在运算对象右侧插入值为0的二进制位。
- 右移运算符 `>>` 的行为依赖于其左侧运算对象的类型：
  - 如果该运算对象是无符号类型，在其左侧插入值为0的二进制位。
  - 如果是带符号类型，在其左侧插入符号位的副本或者值为0的二进制位，如何选择视具体环境而定。
- 右边操作数要求必须是非负数的，并且值必须严格小于结果的位数，否则结果是未定义的。

#### 位与、或、异或操作符

通常位于、或、异或用来检查和设置掩码。如：

```
quiz1 |= 1UL << 27; 	//@将 quiz1 的第 27 位设置为 1
quiz1 &= ~(1UL << 27); //@将 quiz1 的第 27 位设置位 0
bool status = quiz1 & (1UL << 27); //@ 测试 27 位是否位 1
```

## `sizeof` 运算符

`sizeof` 运算符返回一个表达式或一个类型名字所占的字节数，返回值是 `size_t` 类型。

- 操作符形式如：

```
sizeof (type)
sizeof expr
```

- `sizeof` 操作符并不会对表达式进行求值，而是推断其结果类型，在 `sizeof` 的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。
- `sizeof` 运算符的结果部分依赖于其作用的类型：
  - 对 `char` 或者类型为 `char` 的表达式执行 `sizeof` 运算，返回值为1。
  - 对引用类型执行 `sizeof` 运算得到被引用绑定的对象所占空间的大小。
  - 对指针执行 `sizeof` 运算得到指针本身所占空间的大小。
  - 对解引用指针执行 `sizeof` 运算得到指针指向的对象所占空间的大小，指针不需要有效。
  - 对数组执行 `sizeof` 运算得到整个数组所占空间的大小。
  - `sizeof` 返回的大小不会包含动态分配的内存，因而对于 `vector` 类型不会包含分配的元素的内存大小。

## 逗号运算符

逗号运算符 `,` 含有两个运算对象，按照从左向右的顺序依次求值，最后返回右侧表达式的值，如果右操作数是左值返回的结果就是左值。

逗号操作符常用于 `for` 的条件部分:

```
vector<int>::size_type cnt = ivec.size();
for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
	ivec[ix] = cnt;
```

## 类型转换

C++ 中的类型之间存在转换，当需要其中一种类型值时，可以用另一种类型值替换。

当不需要程序员干预就可以自动发生的转换称为隐式转换：

- 在几乎所有的表达式中，小整型将首先进行整型提升。
- 在条件部分，非 `bool` 值将首先转为 `bool` 值。
- 在初始化或者赋值表达式中，右边的值类型转为左边值类型。
- 在算数和条件表达式中，操作数的类型转为一个共同的不丢失精度的类型。
- 函数调用时实参类型转为形参类型。

### 其它隐式转换

- 在大多数表达式中，数组名字自动转换成指向数组首元素的指针。
- 常量整数值0或字面值 `nullptr` 能转换成任意指针类型；指向任意非常量的指针能转换成 `void*`；指向任意对象的指针能转换成 `const void*`。
- 任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是 `false`，否则是 `true`。
- 指向非 `const` 对象的指针可以转为指向 `const` 对象指针，于引用是一样的，反之则不行。
- 类可以通过定义单参数的构造函数来实现由其参数类型到类类型的转换，除非显式禁止，编译器会自动进行如此转换。

### 显式转换

显式类型转换也叫做强制类型转换。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。

C 风格强转形如：

```
type (expr);  //@ 函数风格
(type) expr;  //@ C 语言风格
```

C++ 中显式的强制类型转换形式如下：

```
cast-name<type>(expression);
```

- `type` 是转换的目标类型，`expression` 是要转换的值。

- 如果 `type` 是引用类型，则转换结果是左值。
- `cast-name` 是 `static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast` 中的一种，用来指定转换的方式。

#### `static_cast`

任何明确定义的类型转换，只要不包含底层 `const`，都可以使用。 例如：

- 算数类型之间的转换。
- 将 `void*` 指针转为实际的类型指针。
- 指向基类的指针转为指向子类的指针。

对于这种转换，C++ 语言本身不做任何运行时安全检查。相对的，`dynamic_cast` 将会对转换类型进行运行时检查，确保确实可以从基类指针转为子类指针。

#### `const_cast`

用于改变操作数的底层 `const`，最常用的是去掉 `const` 修饰。

#### `reinterpret_cast`

`reinterpret_cast` 将执行位模式的重新解释，这样可以将一个类型转为任何别的类型。主要用于内置类型的转换，运用于非内置类型可以肯定是错误的。如：

```
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

接下来的操作将会假设 `pc` 指向一个 `char` 类型值，编译器将无法对真实类型做检查。好处在于灵活性，特别是处理网络层读写时经常用到。

## 运算符优先级

| **结合律** | **运算符**    | **功能**           | **使用形式**          |
| ---------- | ------------- | ------------------ | --------------------- |
| 左         | ::            | 全局作用域         | ::name                |
| 左         | ::            | 类作用域           | class::name           |
| 左         | ::            | 命名空间作用域     | namespace::name       |
| 左         | .             | 成员选择           | object.name           |
| 左         | ->            | 成员选择           | pointer->member       |
| 左         | []            | 下标               | expr[expr]            |
| 左         | ()            | 函数调用           | name(expr_list)       |
| 左         | ()            | 类型构造           | type(expr_list)       |
| 右         | ++            | 后置递增运算符     | lvalue++              |
| 右         | --            | 后置递减运算符     | lvalue--              |
| 右         | typeid        | 类型ID             | typeid(type)          |
| 右         | typeid        | 运行时类型ID       | typeid(expr)          |
| 右         | explicit_cast | 类型转换           | cast_name<type>(expr) |
| 右         | ++            | 前置递增运算符     | ++lvalue              |
| 右         | --            | 前置递减运算符     | --lvalue              |
| 右         | ~             | 位求反             | ~expr                 |
| 右         | !             | 逻辑非             | !expr                 |
| 右         | -             | 一元负号           | -expr                 |
| 右         | +             | 一元正号           | +expr                 |
| 右         | *             | 解引用             | *expr                 |
| 右         | &             | 取地址             | &lvalue               |
| 右         | ()            | 类型转换           | (type)expr            |
| 右         | sizeof        | 对象的大小         | sizeof expr           |
| 右         | sizeof        | 类型的大小         | sizeof(type)          |
| 右         | sizeof...     | 参数包的大小       | sizeof ...(name)      |
| 右         | new           | 创建对象           | new type              |
| 右         | new []        | 创建数组           | new type[size]        |
| 右         | delete        | 释放对象           | delete expr           |
| 右         | delete[]      | 释放数组           | delete [] expr        |
| 右         | nonxcept      | 能否抛出异常       | noexcept(expr)        |
| 左         | ->*           | 指向成员选择的指针 | ptr->*ptr_to_member   |
| 左         | .*            | 指向成员选择的指针 | obj.*ptr_to_member    |
| 左         | *             | 乘法               | expr*expr             |
| 左         | /             | 除法               | expr /expr            |
| 左         | %             | 取余               | expr%expr             |
| 左         | +             | 加法               | expr+expr             |
| 左         | -             | 减法               | expr-expr             |
| 左         | <<            | 向左移位           | expr<<expr            |
| 左         | >>            | 向右移位           | expr>>expr            |
| 左         | <             | 小于               | expr<expr             |
| 左         | <=            | 小于等于           | expr<=expr            |
| 左         | >             | 大于               | expr>expr             |
| 左         | >=            | 大于等于           | expr>=expr            |
| 左         | ==            | 相等               | expr==expr            |
| 左         | !=            | 不相等             | expr!=expr            |
| 左         | &             | 位与               | expr&expr             |
| 左         | ^             | 位异或             | expr^expr             |
| 左         | \|            | 位或               | expr\|expr            |
| 左         | &&            | 逻辑与             | expr&&expr            |
| 左         | \|\|          | 逻辑或             | expr\|\|expr          |
| 右         | ?:            | 条件               | expr？expr:expr       |
| 右         | =             | 赋值               | lvalue = expr         |
| 右         | *=，/=，%=    | 复合赋值           |                       |
| 右         | +=，-=        | 复合赋值           |                       |
| 右         | <<=,>>=       | 复合赋值           |                       |
| 右         | &=,\|=,^=     | 复合赋值           |                       |
| 右         | throw         | 抛出异常           | throw expr            |
| 左         | ，            | 逗号               | expr,expr             |

