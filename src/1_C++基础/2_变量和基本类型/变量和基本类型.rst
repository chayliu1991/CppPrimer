.. contents::
   :depth: 3
..

变量和基本类型
==============

基本内置类型
------------

算数类型
~~~~~~~~

算术类型包含两种形式：整数类型（包含字符和布尔类型）和浮点数类型。

内置类型的大小在不同的机器上很可能是不一致的，标准只说明了编译器必须保证的最小尺寸，但是编译器可以提供更大的尺寸，不同的尺寸导致可表示的数字范围不一样。

=============== ============== ==============================
类型            含义           最小尺寸
=============== ============== ==============================
``bool``        布尔类型       8bits
``char``        字符           8bits
``wchar_t``     宽字符         16bits
``char16_t``    Unicode字符    16bits
``char32_t``    Unicode字符    32bits
``short``       短整型         16bits
``int``         整型           16bits
``long``        长整型         32bits
``long long``   长整型         64bits （是在C++11中新定义的）
``float``       单精度浮点数   6位有效数字
``double``      双精度浮点数   10位有效数字
``long double`` 扩展精度浮点数 10位有效数字
=============== ============== ==============================

整数类型
^^^^^^^^

-  ``bool`` 类型的取值是 ``true``\ 或 ``false`` 。
-  一个 ``char``
   的大小和一个机器字节一样，确保可以存放机器基本字符集中任意字符对应的数字值。\ ``wchar_t``\ 确保可以存放机器最大扩展字符集中的任意一个字符。\ ``char16_t``
   和 ``char32_t`` 则用于 Unicode
   字符集，它们的长度如类型名中的数字所示。
-  在整型类型大小方面，C++ 规定 ``short`` ≤ ``int`` ≤ ``long`` ≤
   ``long long``\ （\ ``long long``\ 是C++11定义的类型）。现代计算机中
   ``short`` 通常为 16 位，\ ``int`` 为 32 位，\ ``long`` 在 32
   位机器上是 32 位，在 64 位机器上是 64 位。

浮点数类型
^^^^^^^^^^

浮点数类型常用的有两种：单精度 ``float`` 类型和双精度 ``double``
类型还有扩展精度 ``long double`` 类型。

目前所有现代计算机都遵循 IEEE 754 浮点数标准。\ ``long double`` 可能是
96 位或 128
位，通常用于容纳特殊目的的浮点数硬件，且精度在不同实现之间不同。

有符号和无符号类型
^^^^^^^^^^^^^^^^^^

目前所有现代计算机都用二进制补码来表示有符号整数类型。带符号类型可以表示正数、负数和0，无符号类型只能表示大于等于0的数值。除去布尔型和扩展字符型（wchar_t,
char16_t,
char32_t），其他整型可以分为带符号（signed）和无符号（unsigned）两种。

-  类型 ``int``\ 、\ ``short``\ 、\ ``long``\ 和 ``long long``
   都是带符号的，在类型名前面添加 ``unsigned``
   可以得到对应的无符号类型，如： ``unsigned int``\ 。

-  字符型分为 ``char``\ 、\ ``signed char`` 和
   ``unsigned char``\ 三种，但是表现形式只有带符号和无符号两种。类型\ ``char``
   和 ``signed char`` 并不一样， ``char``
   的具体形式由编译器（compiler）决定。

决定使用何种内置类型的建议
^^^^^^^^^^^^^^^^^^^^^^^^^^

-  当知道值不可能为负数时用 ``unsigned`` 类型；
-  在算数运算中使用 ``int`` 。\ ``short`` 的运算速度和容量都不及
   ``int``\ ，而 ``long`` 在 32 位机器与 ``int`` 大小一致。如果值超出
   ``int`` 的最小保证范围，使用 ``long long``\ 。
-  在算数表达式中不要使用 ``char`` 和 ``bool``
   类型。如果需要使用一个不大的整数，应该明确指定它的类型是
   ``signed char`` 还是 ``unsigned char``\ 。
-  将 ``double`` 用于浮点运算， ``float`` 通常精度不够而且 ``double``
   的运算时间可能还优于 ``float`` ，\ ``long double``
   除非在特殊场景下几乎不会使用到。

类型转换
~~~~~~~~

进行类型转换时，类型所能表示的值的范围决定了转换的过程。

-  把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为
   ``false``\ ，否则结果为 ``true``\ 。
-  把布尔值赋给非布尔类型时，初始值为 ``false`` 则结果为0，初始值为
   ``true`` 则结果为1。
-  把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分。
-  把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
-  赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如：\ ``unsigned char``
   的取值范围是 0~255，如果被赋的值大于等于 256 ，则将对 256
   取模再赋值，-1 取模为 255。
-  赋给带符号类型一个超出它表示范围的值时，结果是未定义的。

类型转换的详解
^^^^^^^^^^^^^^

整型提升
''''''''

字符类型、\ ``short`` 类型或者枚举在表达式中使用，如果 ``int``
可以表示原始值将转为 ``int`` 值，否则转为 ``unsigned int``
值，这个过程称为整型提升。

整型转换
''''''''

任何一个整数转为指定的无符号类型是对无符号值的最大值加一取模，取模的结果一定是非负数。

当将任何整数转为有符号类型时，如果目的类型可以表示原始值，值将不变，否则结果由编译器实现决定。

整数和浮点数
''''''''''''

当将浮点数转为整型时，小数点后的部分将被截断。如果结果值无法被此整型表示，结果是未定义的。特别是将负的浮点数转为无符号整型时，结果未定义。当将整数转为浮点数时，如果值在浮点数的范围内，但没法达到对应的精度时，结果要么是最接近的更大值要么是最接近的更小值。如果值超出了范围，结果是未定义的。

浮点类型
''''''''

将精度更小的浮点数转为精度更大的浮点数，值不变。将精度更大的浮点数转为精度更小的浮点数，结果遵循整数转为浮点数的规则。

算术转换
''''''''

所有算术运算符都有可能引起类型转换，结果是将操作数转为一个相同的类型，同时也是结果的类型，这种行为称为算术转换。

-  如果任何一个操作数是 ``long double`` 时，其它的操作数转为
   ``long double``;
-  否则，如果一个操作数是 ``double`` 时，其它的操作数转为 ``double``;
-  否则，如果一个操作数是 ``float`` 时，其它操作数转为 ``float``;
-  否则，先执行整型提升，如果一个操作数是 ``unsigned long int``
   时，其它的类型转为 ``unsigned long int``;
-  否则，如果一个操作数是 ``long int`` 而另一个是 ``unsigned int``
   时，结果取决于 ``long int`` 是否能够表示 ``unsigned int``
   的所有值，如果可以则\ ``unsigned int`` 转为
   ``long int``\ ，否则两者都转为 ``unsigned long int``;
-  否则，如果一个操作数是 ``long int``\ ，其它的操作数转为
   ``long int``\ ；
-  否则，操作数都是 ``int`` 类型。

避免无法预知和依赖于实现环境的行为
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

无符号数不会小于0这一事实关系到循环的写法
'''''''''''''''''''''''''''''''''''''''''

::

   for (unsigned u = 10; u >= 0; --u) //@ 当 u 等于0时，--u 的结果将会是4294967295。
       std::cout << u << std::endl;

不要混用有符号和无符号类型
''''''''''''''''''''''''''

当有无符号值参与运算时，通常结果就是无符号值，此时即便在我们的直觉中值应该是负数，数值会被解释为一个很大的无符号值。

::

   unsigned u1 = 42, u2 = 10;
   std::cout << u1 - u2 << std::endl; //@ 32
   std::cout << u2 - u1 << std::endl; //@ 4294967264

字面值常量
~~~~~~~~~~

字面量用来描述数字、字符和字符串的值，字面量是常量。每个字面量都有类型，字面量的形式和值决定了其类型。

整型字面值常量
^^^^^^^^^^^^^^

以\ ``0``\ 开头的整数代表八进制（octal）数，以 ``0x`` 或 ``0X``
开头的整数代表十六进制（hexadecimal）数。在 C++14中，\ ``0b`` 或 ``0B``
开头的整数代表二进制（binary）数。

-  十进制是有符号的，从 ``int``, ``long`` 或 ``long long``
   中选择最小可容纳数值的类型。
-  八进制和十六进制可以是无符号或者有符号的，从 ``int``, ``unsigned``,
   ``long``, ``unsigned long``, ``long long`` 或 ``unsigned long long``
   中查找适合的类型。

如果数值大于最大的类型的范围则会产生错误。没有 ``short`` 类型的字面量。

添加特定的后缀或者后缀组合可以改变整型字面值的默认类型：

======= =========
后缀    最小类型
======= =========
U 或 u  unsigned
L 或 l  long
LL或 ll long long
======= =========

以上后缀适用于十进制、八进制和十六进制。如：\ ``0XFUL`` 是
``unsigned long`` 类型的值 15 ，1234L 则是 ``long`` 类型的值 1234 。

浮点型字面值常量
^^^^^^^^^^^^^^^^

浮点型字面值可以使用小数的方式表示，也可以使用科学计数法表示。

浮点型字面值默认是一个 ``double``\ 。

添加特定的后缀或者后缀组合可以改变浮点型字面值的默认类型：

====== ===========
后缀   类型
====== ===========
f 或 F float
l 或 L long double
====== ===========

字符型字面值
^^^^^^^^^^^^

字符常量值是一个整数。字符写做单引号中的单个字符如：\ ``'x'``\ ，值是字符在机器字符集中的数字表示值。

C++ 和 C
中定义了几个可以的字符，这些字符通常是不可打印或者在字符串中有特殊含义。

========== ==========
字符字面值 含义
========== ==========
``\n``     换行符
``\t``     横向制表符
``\a``     响铃
``\v``     纵向制表符
``\b``     退格符
``\"``     双引号
``\\``     反斜线
``\?``     问号
``\'``     单引号
``\r``     回车符
``\f``     进纸符
========== ==========

泛化转义序列的形式是 ``\x`` 后紧跟1个或多个十六进制数字，或者 ``\``
后紧跟1个、2个或3个八进制数字，其中数字部分表示字符对应的数值。

如果 ``\`` 后面跟着的八进制数字超过3个，则只有前3个数字与 ``\``
构成转义序列。相反，\ ``\x``\ 要用到后面跟着的所有数字。

添加特定的前缀指定字符型字面值的类型：

==== ==================== ========
前缀 含义                 类型
==== ==================== ========
u    Unicode 16 character char16_t
U    Unicode 32character  char32_t
L    wide charater        wchar_t
==== ==================== ========

字符串字面值
^^^^^^^^^^^^

字符串字面值是双引号中的 0 个或多个字符。

字符串字面量就是字符数组，并且编译器会在字符串的末尾隐式加上一个 ``\0``
字符。所以字符串的真正长度比看起来多了一个字符。如：\ ``"A"``
有两个字节。

以上字符型字面值的转义同样适用于字符串字面值。

两个相邻的字符串（中间只有空白符）会在编译期间拼接成一个字符串，通常如果字符串太长时会这么做。

::

   cout << "hello" 
       " world"<< endl;   //@ hello world

添加特定的前缀指定字符串型字面值的类型：

==== ==================== ========
前缀 含义                 类型
==== ==================== ========
u    Unicode 16 character char16_t
U    Unicode 32character  char32_t
L    wide charater        wchar_t
u8   utf-8                char
==== ==================== ========

其它字面值常量
^^^^^^^^^^^^^^

-  ``true`` 和 ``false`` 是 ``bool`` 类型的常量。
-  ``nullptr`` 是指针的常量，在 C 中一般写做 ``NULL`` 宏。

变量
----

变量提供一个具名的、可供程序操作的存储空间。 C++
中变量和对象一般可以互换使用。
