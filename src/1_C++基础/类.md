# 类

类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程及设计技术。

- 类的接口包括用户所能执行的操作。
- 类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。

## 定义抽象数据类型

成员函数的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。

成员函数通过一个名为 `this` 的隐式额外参数来访问调用它的对象。`this `参数是一个常量指针，被初始化为调用该函数的对象地址。

- 在函数体内可以显式使用 `this` 指针。
- `this` 是一个 `const` 指针，不能改变 ` this` 使其指向别的对象。

参数列表后的 `const` 用来说明 `this` 指针指向 `const` 对象：

- 通常情况下 `this` 是指向非 `const` 对象的 `const` 指针，不能将非 `const` 的 `this` 指向 `const` 对象，从而不能在 `const` 对象上调用非 `const` 的函数。
- 为了在 `const` 对象上调用成员函数，必须使得 `this` 指向 `const` 对象，所以语言通过在参数列表后放置 `const` 来表明 `this` 指针指向 `const` 对象，从而使得此成员函数称为 `const` 成员函数。
- 常量对象和指向常量对象的引用或指针都只能调用常量成员函数。

### 定义类

#### 类作用域和成员函数

类本身就是一个作用域，所以，成员函数的定义处于类作用域中。

编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话，因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。

#### 在类外部定义成员函数

当在类外部定义成员函数时需要定义与声明完全一致。特别是参数列表后的 `const` 需要一致。

在类外定义的成员名字必须用类名加以限定。

#### 定义函数返回“当前”对象

返回当前对象意味着需要返回当前对象的引用，而且需要在返回时对 `this` 进行解引用。如：

```
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

###  定义类相关的非成员函数

类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。

```
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}

ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```

如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。

### 构造函数

类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。构造函数的工作就是初始化类的数据成员，每当对象创建时构造函数就会调用。

- 构造函数与类名相同而且没有返回值，除此之外与常规函数没有别样。

- 构造函数与常规函数一样可以进行重载。

- 构造函数不能被声明为 `const` 的，原因在于即便是 `const` 对象亦需要在构造函数完成初始化之后才能变成常量。

####  合成默认构造函数

当定义对象时不给定初始值将执行默认初始化。类控制默认初始化的构造函数称为默认构造函数。

- 默认构造函数是没有任何参数。
- 如果类没有显式定义任何构造函数，编译器会隐式定义一个默认构造函数，这个生成的默认构造函数称为合成默认构造函数。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：
  - 如果有类内初始值，就用那个初始值进行初始化。
  - 如果没有，则使用默认初始化，对于类成员将调用其默认构造函数，对于内置类型则不进行任何初始化。

##### 一些类不能依赖于合成默认构造函数

某些类不能依赖于合成的默认构造函数。

- 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。
- 如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。
- 编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。

在 C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加 `=default` 来要求编译器生成构造函数。`=default` 可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果`=default`在类的内部，则默认构造函数是内联的。

##### 构造初始值列表

在 C++11 之后才提供类内初始化，在之前的 C++ 版本是不提供的，此时必须使用构造初始值列表来初始化所有成员。

构造函数初始值列表负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。

当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。

构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。

### 拷贝、赋值和析构

除了定义类对象如何初始化，类还可以控制对象赋值、赋值和销毁时的操作。

- 当初始化变量或者传递参数、返回值时将发生对象复制。

- 当使用赋值操作符时发生赋值操作。
- 当离开定义对象所在的块时将销毁对象，将发生析构。

如果程序员不定义这些操作的函数，编译器将合成这些函数。通常，编译器生成的版本就是将对象的每个成员分别进行拷贝、赋值和销毁。

对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。

## 访问控制和封装

在 C++ 中使用访问说明符来强制封装，即信息隐藏：

- `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
- `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。

一个类可以有零个或多个访问说明符，对于一个访问说明符出现的频率并没有限制。

每个访问说明符说明接下来的成员访问级别，这些访问级别持续到下一个访问说明符的出现或者类的结尾。

#### 使用 class 或 struct 关键字

都可以被用于定义一个类。唯一的却别在于访问权限：

- 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
- 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

#### 友元

类可以允许其他类或函数访问它的非公有成员，方法是使用关键字 `friend` 将其他类或函数声明为它的友元。

- 友元声明需要放在类定义内，它们可以出现在类的任何地方。
- 友元不是类的成员，因而，不受访问控制的影响。
- 将所有的友元声明集中放在一起，或置于类定义头部或尾部，是一个好的处理方式。
- 友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。为了使友元对类的用户可见，就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，通常会把友元的声明与类本身放在同一个头文件中。

#### 封装的益处

- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

## 其它类特性

### 类成员再探

#### 类中定义类型别名

类可以使用 `typedef` 或 `using` 为类型定义自己的本地名字，由类定义的类型名字可以像其它成员一样定义其访问权限。如：

```
class Screen {
public:
    typedef std::string::size_type pos;
    
//@ 或者
public:
    using pos = std::string::size_type;
};
```

- 在 `public` 部分定义 `pos` 类型，这样用户代码亦可以通过 `Screen::pos` 使用此名字。

- 需要注意的一点是，与常规成员不同，类型别名定义需要出现在任何其被使用之前。因而，类型成员通常出现在类定义的顶部。

#### 将成员函数设为 inline

定义在类内部的成员函数是自动内联的。

可以显式将成员函数声明为 `inline` 的，有两种方式：

- 一种是在类定义内的成员函数声明处声明.
- 另一种是在类外面的成员函数定义处声明。
- 同时在两处都声明内联是合法的。书中认为仅在类外的定义处声明内联可以使得类更加易读。

#### 重载成员函数

与常规函数一样，成员函数亦是可以重载的。而且函数匹配的规则与常规函数的匹配是一样的。

#### mutable数据成员

使用关键字 `mutable` 可以声明可变数据成员。

可变数据成员永远不会是 `const` 的，即使它在 `const` 对象内。因此 `const ` 成员函数可以修改可变成员的值。

#### 类类型数据成员的初始值

在新标准中，除了可以为内置类型数据成员设定类内初始值外，亦可以为类类型数据成员设定初始值。而且，在新标准中最好的设置默认值的方式就是类内初始值。如：

```
class Window_mgr {
private:
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```

- 当初始化类类型成员时，其实是通过提供实参给那个类的构造函数并调用而进行初始化。
- 类内初始值遵循一种格式规范即：要么用等号 `=`形式，要么用大括号  `{}` 形式进行初始化。除此之外的形式都是不合法的。

#### 返回*this的成员函数

函数返回引用即其结果为左值，意味着返回的是对象本身而不是对象的拷贝。如果将操作串连起来就是连续对此对象进行操作。

```
myScreen.move(4, 0).set('#');   //@ move 函数返回 *this，可以继续操作 set
```

如果返回的是对象，而不是引用，那么以上操作中的 `set` 就是对返回的临时量进行操作，而不是对对象本身进行操作：

```
Screen temp = myScreen.move(4, 0);
temp.set('#');
```

`const` 成员函数返回的 `*this` 是一个 `const` 引用，因为，`this` 是一个指向 `const` 对象的指针。这将导致其不能与返回 `*this` 的非 `const` 成员函数串连在一起。

通过区分成员函数是否为 `const` 的，可以对其进行重载：

- 在常量对象上只能调用 `const` 版本的函数。
- 在非常量对象上，尽管两个版本都能调用，但会优先选择非常量版本。

### 类类型

C++ 中的类按名字进行区分，每个类就是一个独特的类型。两个不同的类即便有完全一致的代码亦是不同类型。两个类中的成员是完全独立的。

使用类类型有两种方式：直接使用类的名字，或者在类名前面加上 `class` 或 `struct`，如：

```
Sales_data item1;
class Sales_data item1;
```

#### 类声明

可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明，用于引入类的名字。在类声明之后定义之前都是一个不完全类型。

未完成类型的使用有诸多限制：可以定义这种类型的指针或引用，可以声明（但不能定义）使用未完成类型作为参数或返回值的函数。

只有当知道类的定义时，才能书写创建这种类型对象的代码，否则，编译器不知应当如何存储对象。

一个类不能定义其本身类型的数据成员，但是可以定义本身类型的指针或引用。

### 友元再探

一个类可以使得另一个类作为其友元类，或者将指定特定的成员函数作为其友元。

如果一个友元函数定义在类的内部，这个函数则隐式成为内联的。

#### 类之间的友元关系

友元类的成员函数可以访问授权类的所有成员，包括所有非公有的成员。

友元关系是不可传递的。一个类是另一个类的友元并不意味着这个类自己的友元可以访问那个类，每个类控制着哪些函数或类是自己的友元。

#### 使成员函数成为友元

除了可以使得整个类作为友元，类还可以使得特定的成员函数作为友元。当指定成员函数作为友元时需要指定是哪一个类的成员。如：

```
class Screen {
friend void Window_mgr::clear(ScreenIndex);   //@ 指明成员函数属于哪个类
};
```

尽管重载的函数使用的是同一个名字，它们依然是不同的函数。因而，声明友元函数时必须显式指定其中想要的函数原型，单单声明一个并不会将整个重载的函数集加入进来。如：

```
class Screen {
friend std::ostream &storeOn(std::ostream&, Screen&);
friend BitMap& storeOn(BitMap&, Screen&);
};
```

#### 友元声明和作用域

需要理解的是友元声明仅仅影响访问权限，其并不是真正的声明形式。

```
struct X {
	friend void f() { /* function body */ }
	X() { f(); }  //@ 错误，未声明函数 f
	void g();
	void h();
};

void X::g() { return f(); }  //@ 错误!! f 未声明
void f();
void X::h() { return f(); }  //@正确，此时 f 已经被声明了
```

## 类作用域

每个类定义其自己的新作用域。在类作用域外，必须通过对象、引用或指针以成员访问符来访问数据和函数成员。

#### 定义在类外的成员及其与类作用域的关系

存在类作用域的事实解释了为何在类外定义成员函数时必须同时提供类名和函数名。因为在类外，其成员的名字将被隐藏。

- 一旦遇到了类名，剩下的定义部分（包括形参列表和函数体）就在类作用域内，因此，不需要类名进行限定就可以使用其它类成员

- 当一个成员函数在类外定义时，由于返回类型出现函数名字前，此时作用域并不在类作用域内，因而，必须加上类的名字进行限定。如：

```
Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s);
```

并且，仅在类成员函数定义时才能够在类名后进入类作用域，返回值类型并不会使得进入限定其的类名的作用域。

### 名称查找和类作用域

类定义分为两步：

- 其一，成员的声明被编译。
- 其二，当整个类定义完成时，成员函数定义将被编译。

因此，成员函数体可以使用类中的任何名字。特别是，可以使用在成员函数体后才声明的名字。否则，处理成员声明的顺序将是脆弱而复杂的。

#### 类成员声明的名称查找

对于运用于声明中的名字，包括返回值类型和参数列表中的类型则必须在使用前是可见的。如果成员声明使用了类此刻未见的名字，编译器将在类定义的外部作用域寻找此名字。

```
typedef double Money;
string bal;
class Account {
public:
    //@ Money 使用的是外部声明的，bal 则使用的后面声明的。这是两步走的缘故。
    Money balance() { return bal; }
private:
    Money bal;	//@ 隐藏类外部作用域的名字
};
```

#### 类型名字是特殊的

通常，内部作用域可以重定义外部作用域中的名字，即便那个名字已经被用于内部作用域。

然而，在类中如果一个成员使用了外部作用域中的名字，而此名字是一个类型，那么在类中就不能重定义此名字。如：

```
typedef double Money;
class Account {
public:
    Money balance() { return bal; } //@ Money 是外部作用域的名字
private:
    typedef double Money; //@ 错误!!不能重定义 Money 类型
    Money bal;
};
```

尽管此重定义类型名字是一种错误，编译器并不一定识别此错误。一些编译会静默的接受这样的代码，即便这样的程序是错的。

类型定义应该放在类的头部，这样其它成员就可以看到此类型定义。

**成员函数体内的名字查找规则**

成员函数体中使用的名字通过如下方式进行查找：

- 在成员函数内查找声明，只有出现在使用之前的声明才是可见的；
- 如果未找到，在类定义内查找声明，所有的成员的名字都可见；
- 如果未找到，继续从定义成员函数定义所在的作用域内向上查找，如果成员函数定义在类中则从类外部作用域查找，如果成员函数定义在类外，则从类外的位置向上查找；

通常定义参数名字与别的成员名字一样是不好的行为，如果这样的话，函数内部使用的名字将是参数名字而不是成员名字。可以通过加上类名进行限定而访问成员名字，或者使用 `this` 指针进行访问。然而最好的方式是给参数取一个不同的名字。如：

```
int height;
class Screen {
public:
	typedef std::string::size_type pos;
	void dummy_fcn(pos height)
	{
		cursor = width * height; //@ 访问参数而非成员
		cursor = width * this->height; //@  用 this 访问
		cursor = width * Screen::height; //@ 用类名进行限定
		cursor = width * ::height; //@ 访问全局作用域中的 height
	}
private:
	pos cursor = 0;
	pos height = 0, width = 0;
};
```

如果外部作用域中的名字被类作用域中相同名字给隐藏了，可以通过作用域操作符 `:: ` 显式访问全局中的名字。

#### 名字在它们出现在文件中的位置进行解析

当成员定义在类外时，名字查找的第三步会检查函数定义所在的地方，也会继续往上查找穿过类定义的位置。如：

```
class Screen {
public:
	typedef std::string::size_type pos;
	void setHeight(pos);
	pos height = 0;
};

Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
	height = verify(var);
}
```

这里的 `verify` 是不为类定义 `Screen` 所见的，因而不能运用于类定义中。但是，类外定义的成员函数 `setHeight` 却可以看到此名字，函数体内的名字并不是从类体处开始查找的，而是从函数定义处开始查找的。

## 构造函数再探

### 构造初始值列表

当定义变量时通常是马上进行初始化而不是定义了然后再进行赋值。这种区别同样运用于数据成员的初始化和赋值。如果不在构造初始值列表中显式初始化，成员将会被默认初始化，然后才进入构造函数体中。如：

```
Sales_data::Sales_data(const string &s, unsigned cnt, double price)
{
    bookNo = s;
    units_sold = cnt;
    revenue = cnt * price;
}
```

这个版本的构造函数将先默认初始化数据成员，然后在函数体内进行赋值。

如果数据成员是类类型，那么则会先调用其默认构造函数，再调用其重载后的赋值操作符，这可能造成低效或者某些类甚至是错误的。

- 如果成员是 `const`、引用，或者是某种未定义默认构造函数的类类型，必须在初始值列表中将其初始化。
- 最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。
- 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 委托构造函数

委托构造函数使用本类的另一个构造函数才执行初始化。即将一些或者全部工作“委托”给其它构造函数完成。

委托构造函数的构造初始值列表中只有一项就是另外一个构造函数的调用，实参列表必须匹配另外一个构造函数的签名。如：

```
class Sales_data {
public:
    Sales_data(std::string s, unsigned cnt, double price):
        bookNo(s), units_sold(cnt), revenue(cnt*price) {}
    Sales_data(): Sales_data("", 0, 0) {}
    Sales_data(std::string s): Sales_data(s, 0, 0) {}
};
```

当一个构造函数委托给另外一个构造函数时，被委托构造函数的构造初始值列表和函数体都会先于委托构造函数执行，意味着在委托构造函数体开始执行之前，被委托构造函数体将先执行完，这跟初始化器的行为是一致的。





###  默认构造函数的角色

当执行默认初始化或值初始化时，默认构造函数将被自动调用。

值初始化所做的事：如果类有用户提供默认构造函数，则直接调用此构造函数。如果默认构造函数是编译器隐式定义的，那么所有的非静态成员将递归值初始化。这里隐含的意思在于用户提供的默认构造函数如果不对某些内置类型的数据成员进行初始化，那么它将是未定义值。而由编译器隐式定义的默认构造函数，在值初始化时会对整个对象进行零初始化。

如果定义了任何构造函数，好的做法是同时提供一个默认构造函数。并且，构造函数应当初始化所有成员。

如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号：

```
Sales_data obj();   //@ 定义了一个函数，而不是一个对象
Sales_data obj2;    //@ 正确，obj2 是一个对象
```

### 隐式类类型转换

如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为转换构造函数。

```
//@ Sales_data
string null_book = "9-999-99999-9";
item.combine(null_book);
```

`combine` 成员函数的参数是 `const Sales_data&` ，而 `Sales_data` 有一个以 `string` 为参数的构造函数。因而，这种形式的 `combine` 调用，会以 `null_book` 创建一个 `Sales_data` 的临时量，再以此临时量调用 `combine` 函数。

编译器只允许一次类类型的自动转换。如：`item.combine("9-999-99999-9");` 是不能编译通过的。原因在于，从字符指针到 `Sales_data` 对象需要经过两步转换。为了进行此调用，必须进行显式的转换。如：

```
item.combine(string("9-999-99999-9"));
item.combine(Sales_data("9-999-99999-9"));
```

有时这种类类型的自动转换根本不是程序员的意图，这样做只会增加理解程序的负担，而且产生的错误还可能是难以发现的。

通过在构造函数前加上 `explicit` 关键字，来抑制此构造函数被用于隐式转换。如：

````
class Sales_data {
public:
    explicit Sales_data(std::istream&);
    explicit Sales_data(const std::string&);
};
````

- `explicit` 关键字只对仅有一个参数的构造函数有效，其它形式的构造函数因为并不用于隐式类型转换，所以并不需要指定为 `explicit `。
- `explicit` 关键只能用于构造函数声明处，不必在类外部函数定义处进行重复。
- `explicit` 构造函数不能用于这种形式，其必须使用直接初始化。如：

```
Sales_data item2 = null_book; //@ explicit 构造函数不能用于拷贝形式的初始化
```

- 尽管不能将 `explicit` 构造函数进行隐式转换，但可以用于显式转换。如：

 ```
item.combine(Sales_data(null_book)); //@ 直接调用构造函数
item.combine(static_cast<Sales_data>(cin)); //@ 使用 static_cast 进行显式转换
 ```

### 聚合类

聚合类可以直接让用户访问其成员，并且有特殊的初始化语法。聚合类有点类似 POD（Plain Old Data）结构，满足以下条件的类可以被称为是聚合的：

- 所有的数据成员是 `public ` 的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类或者虚函数。

如以下类便是聚合的：

```
struct Data {
    int ival;
    string s;
};
```

- 可通过括弧列表中的初始值来初始化聚合类的成员，如：`Data val1 = {0, "Anna"};` 要求是括弧中的初始值需要与声明的数据成员的顺序一致。
- 与初始化数组元素一样，如果初始值列表中的值少于类的成员数，剩余的成员将被值初始化。初始值列表中包含的值一定不能多于类成员数。

聚合类有一些缺陷：

- 将正确初始化所有成员的责任强加在用户身上，这种初始化是冗长而易错的。
- 当类的成员被添加或移除时，所有的初始化的地方都需要更新。

### 字面值常量类

数据成员都是字面值类型的聚合类是字面值常量类。或者一个类不是聚合类，但符合下列条件，则也是字面值常量类：

- 数据成员都是字面值类型。
- 类至少含有一个 `constexpr` 构造函数。
- 如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的 `constexpr` 构造函数。
- 类必须使用析构函数的默认定义。

`constexpr ` 构造函数用于生成 `constexpr` 对象以及 `constexpr` 函数的参数或返回类型。

`constexpr ` 构造函数必须初始化所有数据成员，初始值使用 `constexpr` 构造函数或常量表达式。

## static 成员

使用关键字 `static` 可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。

由于静态成员不与任何对象绑定，因此静态成员函数不能声明为 `const` 的，也不能在静态成员函数内使用 `this ` 指针。

用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。

### 定义静态成员

可以在类的内部或外部定义静态成员函数。当在外部定义时，不需要重复 `static` 关键字，此关键字只应该放在类内的声明处。

- 静态数据成员不能在类内进行初始化，所有的静态数据成员都必须在类外进行定义和初始化，并且只能被定义一次。

- 如全局对象一样，静态数据成员在任何对象之外定义，因而，一旦它们被定义了，它们将持续到程序完全退出。

- 定义静态数据成员需要在成员名之前加上类名进行限定。如：

```
double Account::interestRate = 0
```

- 通常将定义静态数据成员的代码放在与定义类的非内联函数一起的源文件中。

### 静态数据成员的类内初始化

可以在类内为 `const` 整数类型的静态成员进行初始化，并且必须给 ` constexpr` 字面类型的静态成员进行类内初始化。

```
class Account {
    static constexpr int period = 30;
    double daily_tbl[period];
};
```

- 如果在类内提供了初始值，类外的成员定义不需要指定初始值。

```
constexpr int Account::period;  //@ 初始值已经在类内提供了
```

- 以 `const` 修饰的静态成员，如果在类内初始化则是常量表达式，如果在类外进行初始化则为常规的 `const` 常量，而非常量表达式。
- 静态数据成员可以使用未完成的类型。特别是，静态数据成员可以使用当前定义的类本身的类型，而非静态数据成员只能被声明为指针或引用。

```
class Bar
{
    static Bar mem1;   //@ 正确，静态数据成员可以使用未完成的类型
    Bar *mem2;    //@ 正确，可以使用未完成类型的指针
    Bar mem3;   //@ 错误，不能使用未完成类型
}
```

- 可以将静态数据成员作为默认参数，而常规数据成员是不可以的。如：

```
class Screen {
public:
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
```











