# 函数

## 函数基础

典型的函数定义包括返回类型、函数名字、由0个或多个形式参数组成的列表和函数体。函数执行的操作在函数体中指明。

程序通过调用运算符来执行函数。调用运算符的形式之一是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针.

函数调用完成两项工作：

- 用实参初始化对应的形参。
- 将控制权从主调函数转移给被调函数。此时，主调函数的执行被暂时中断，被调函数开始执行。

`return ` 语句结束函数的执行过程，完成两项工作：

- 返回 `return` 语句中的值（可能没有值）。
- 将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果。

### 形参和实参

- 实参用于初始化形参，C++ 是按照参数顺序进行初始化的，并且不保证实参的求值顺序的。

- 传入的参数必须与形参的类型匹配，并且个数也是必须一致的，因而，所有形参都保证一定会初始化。与初始化一样，允许从参数到形参的转换，只要这种转换是合法的。

- 函数的任意两个形参不能同名，函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

- C++ 中可以用一对空括号表示来表示没有参数，C 中早年必须在括号中写 `void` 来表示没有参数。如：

```
void f() {/*...*/}
void f(void) {/*...*/}
```

- 形参的名字是可选的，但是无法使用未命名的形参。即使某个形参不被函数使用，也必须为它提供一个实参。

### 返回类型

返回类型可以是除数组类型和函数类型外的任何类型，可以是 `void` 类型表示没有没有返回值。

虽然不能返回数组和函数，但是可以返回数组的指针和引用，以及函数指针。

### 局部对象

形参和函数体内定义的变量统称为局部变量。

在变量类型前添加关键字 `static` 可以定义局部静态对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序结束才被销毁，对象所在的函数结束执行并不会对它产生影响。

当局部静态对象没有显式初始化时，将执行值初始化，意味着内置类型的本地静态变量将被初始化为 0。

### 函数声明

和变量类似，函数只能定义一次，但可以声明多次。函数声明也叫做函数原型。

函数声明最好是放在头文件中，以保证所有引入的地方都保持一致，改变声明也仅需改变一个地方。实现函数的源文件也需要包含函数声明，这样可以校验定义和声明是否一致。

### 分离编译

分离式编译允许我们把程序按照逻辑关系分割到几个文件中去，每个文件独立编译。这一过程通常会产生后缀名是 `.obj` 或 `.o` 的文件，该文件包含对象代码。之后编译器把对象文件链接在一起形成可执行文件。

## 参数传递

形参初始化的机理与变量初始化一样。

形参的类型决定了形参和实参交互的方式：

- 当形参是引用类型时，它对应的实参被引用传递，函数被传引用调用。引用形参是它对应实参的别名。
- 当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参（值传递），函数被传值调用。

### 传值参数

如果形参不是引用类型，则函数对形参做的所有操作都不会影响实参。

使用指针类型的形参可以访问或修改函数外部的对象。

```
void reset(int *ip)
{
    *ip = 0;  //@ ip 指向的对象值被改变
    ip = 0;   //@ 局部对象 ip 的值被改变，实参的值没有被改变
}
```

在 C++ 中如果想在函数体内访问或修改函数外部的对象，建议使用引用形参代替指针形参。

### 传引用参数

通过使用引用形参，函数可以改变实参的值。

- 使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。
- 除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。
- 如果函数无须改变引用形参的值，最好将其声明为常量引用。
- 一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。

### const 形参和实参

当形参有顶层 `const` 时，传递给它常量对象或非常量对象都是可以的。对于非 const 引用，用于初始化的实参必须是相同类型的。

把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。所以这里有一个原则就是尽可能使用 `const` 引用。

如果重载的函数只是形参的顶层 `const` 修饰不一样，可以用相同的参数去调用这两个函数，编译器没有足够的信息来区分这两个函数。这种情况下将被认为是重复定义。如：

```
void fcn(const int i) { /* ... */}
void fcn(int i) { /* ... */ }  //@ 错误， 重复定义fcn
```

### 数组形参

因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。

```
//@ 函数参数类型都是 const int*
void print(const int*);
void print(const int[]);    
void print(const int[10]); 
```

- 因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。

- 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。
- 以数组作为形参的函数必须确保使用数组时不会越界。有三种方式来定义数组的边界：
  - 设置一个结束的标记，如：C 风格字符串末尾的空字符。
  - 传入头指针和尾后指针。
  - 传入额外的 size 参数。
- 如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。
- 形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。

```
void print(int (&arr)[10]);   //@ 必须将 & 号放在括号内部
```

- 如果以多维数组作为参数传给函数，那么其实传的是指向二级数组的指针，并且子数组的长度是类型的一部分，因而必须指定其长度。如：

```
void print(int(*matrix)[10], int rowSize); //@  * 号必须放在括号内部，表示指针的优先级高于数组 

//@ 等价于
void print(int matrix[][10], int rowSize);
```

### main：处理命令行选项

可以在命令行中向 `main` 函数传递参数，形式如下：

```
int main(int argc, char *argv[]) { /*...*/ }
int main(int argc, char **argv) { /*...*/ }
```

- 第一个形参 `argc` 表示数组中字符串的数量。
- 第二个形参 `argv` 是一个数组，数组元素是指向 C 风格字符串的指针。
- 当实参传递给 `main` 函数后，`argv` 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

### 含有可变形参的函数

#### C语言中的不定形参

C 语言中使用省略号形式的不定形参，形如：

```
void foo(parm_list, ...);
```

其中省略号只能出现在参数列表的末尾。其中 `parm_list`后的逗号可以省略，但最好不要这样做以免引起歧义。

有几个函数来帮助访问省略号形式的可变参数：

- `va_start` ：使得可以开始访问可变参数。
- `va_arg` ：访问下一个可变参数。
- `va_list` ：保存供 `va_start` `va_arg` `va_end` 访问的信息，必须首先调用。
- `va_end` ：结束访问可变参数。

```
#include <iostream>
#include <cstdarg>

void simple_printf(const char* fmt...)
{
	va_list args;
	va_start(args, fmt);

	while (*fmt != '\0') {
		if (*fmt == 'd') {
			int i = va_arg(args, int);
			std::cout << i << '\n';
		}
		else if (*fmt == 'c') {
			int c = va_arg(args, int);
			std::cout << static_cast<char>(c) << '\n';
		}
		else if (*fmt == 'f') {
			double d = va_arg(args, double);
			std::cout << d << '\n';
		}
		++fmt;
	}

	va_end(args);
}

int main()
{
	simple_printf("dcff", 3, 'a', 1.999, 42.5);
}
```

- 省略号形式的参数是不做类型检查的。
- C++ 还可以使用省略符形参传递可变数量的实参，但这种功能一般只用在与 C 函数交换的接口程序中。
- 在 C++ 中省略号形式的参数中如果有类类型，很可能不能正确的进行拷贝。

#### initializer_list

如果实参类型相同，可以使用 `initializer_list` 标准库类型。

`initializer_list` 是一个类模板，表示某种类型的数组，被定义在头文件 `<initializer_list>` 头文件中。以下简单列举此类对象可以执行的操作：

- `initializer_list<T> lst;` 包含元素类型 T 的空列表。     
- `initializer_list<T> lst{a,b,c...};` 将初始化列表中的值拷贝到列表中，最终列表中的值是 `const` 的。      
- `lst2(lst);` 或者 `lst2 = lst;` 这种形式的初始化或赋值不会拷贝元素，而是共享相同的元素。
- `lst.size();` 返回列表的元素个数；
- `lst.begin();` 和 `lst.end();` 返回头元素和尾后元素的迭代器。

需要记住的是 `initializer_list` 中的元素总是 `const` 的，不能改变其中元素的值。当传递给函数 `initializer_list` 参数时需要将序列放在大括弧中。如：

```
void error_msg(initializer_list<string> il);
error_msg({"functionX", "okay", "expected", "actual"});
```

## 返回类型和return语句

`return ` 语句有两种形式，作用是终止当前正在执行的函数并返回到调用该函数的地方。

```
return;
return expression;
```

### 无返回值函数

- 没有返回值的 `return ` 语句只能用在返回类型是 `void` 的函数中。

- 返回 `void` 的函数可以省略 `return` 语句，因为在这类函数的最后一条语句后面会隐式地执行 `return`。
- 一个返回类型是 `void` 的函数也能使用 `return` 语句的第二种形式，不过此时 `return` 语句的 `expression` 必须是另一个返回 `void` 函数。
- 强行令 `void` 函数返回其他类型的表达式将产生编译错误。

### 有返回值函数

- 只要函数的返回类型不是 `void`，该函数内的每条 `return` 语句就必须返回一个值，并且返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型（`main` 函数例外）。

- 函数返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用处的一个临时量，该临时量就是函数调用的结果。

- 如果函数返回引用类型，则该引用仅仅是它所引用对象的一个别名。函数不应该返回局部对象的指针或引用，因为一旦函数完成，局部对象将被释放。

```
const string &manip()
{
    string ret;
    if (!ret.empty())
        return ret;   //@ 错误，返回局部对象的引用
    else
        return "Empty";   //@ 错误，返回局部对象的引用
}
```

- 如果函数返回指针、引用或类的对象，则可以使用函数调用的结果访问结果对象的成员。
- 调用一个返回非 `const` 引用的函数会得到左值，其他返回类型得到右值。返回引用的函数调用可以像别的左值一样操作，特别是可以给结果值赋予别的值。如：

```
char &get_val(string &str, string::size_type ix)
{
    return str[ix];
}
string s("a value");
get_val(s, 0) = 'A';
```

- C++11 规定，函数可以返回用花括号包围的值的列表。同其他返回类型一样，列表也用于初始化表示函数调用结果的临时量。如果列表为空，临时量执行值初始化；否则返回的值由函数的返回类型决定。
  - 如果函数返回内置类型，则列表内最多包含一个值，并且值不能执行精度变小的转换。
  - 如果函数返回类类型，由类本身定义初始值如何使用。

### main函数返回值

- `main` 函数可以没有 `return` 语句直接结束。如果控制流到达了 `main` 函数的结尾处并且没有 `return` 语句，编译器会隐式地插入一条返回0的 `return` 语句。
- `main `函数的返回值可以看作是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。
- 为了使 `main` 函数的返回值与机器无关，头文件 `<cstdlib>` 定义了 `EXIT_SUCCESS` 和 `EXIT_FAILURE` 这两个预处理变量，分别表示执行成功和失败。

### 函数返回指向数组的指针

C++ 中不允许复制数组，函数因而不能声明为返回数组，但可以返回一个指向数组的指针或者数组引用。然而定义返回数组指针或者数组引用的函数有点难懂，因为引用和指针的优先级低于数组索引符。如：

```
int (*func(int i))[10]; //@ 返回指向 int[10] 的指针
int (&func(int i))[10]; //@ 返回 int[10] 的引用
```

为了改善这种难懂的声明式，C 语言提供了 `typedef` ，C++ 提供了新的 `using` 声明。如：

```
typedef int arrT[10];
using arrT = int[10];
arrT* func(int i);
```

C++11允许使用尾置返回类型简化复杂函数声明。尾置返回类型跟在形参列表后面，并以一个 `->` 符号开头。为了表示函数真正的返回类型在形参列表之后，需要在本应出现返回类型的地方添加 `auto` 关键字。

```
auto func(int i) -> int(*)[10];
```

任何函数的定义都能使用尾置返回类型，但是这种形式更适用于返回类型比较复杂的函数。

另外一种做法是用 `decltype` 来推断返回类型，但 `decltype` 并不会把数组类型转换成指针类型，所以还要在函数声明中添加一个 `*` 符号。

```
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
//@ 返回一个指针，指向包含5个int元素的数组
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even;  
}
```

## 函数重载

C 语言是不支持函数重载的，即不允许具有同名函数。C++ 同一作用域内的几个名字相同但形参列表不同的函数叫做重载函数。

- `main ` 函数不能重载。
- 重载的函数必须在参数的个数和类型上有所区别，如果函数仅仅是返回值类型不一致将不符合重载的条件。
- 如果一个函数仅仅是某些参数的顶层 `const` 不符合重载条件。如：

```
Record lookup(Phone phone);
Record lookup(const Phone phone);  //@ 重定义
```

- 底层 `const` 不一致的重载，即指针是否指向 `const` 对象，引用是否绑定到 `const` 对象。不能从 `const` 对象转为非 `const` 对象，而可以从非 `const` 对象转为 `const` 对象:
  - `const` 对象只能用于调用 `const` 版本的函数。
  - 非 `const` 对象可以用于调用这两个版本的函数。如果同时存在两个版本，当使用非` const` 对象进行调用时，编译器会调用非 `const` 版本的函数。

```
Record lookup(Account& account);
Record lookup(const Account& account);
Record lookup(Account* account);
Record lookup(const Account* account);
```

### 调用重载函数

函数匹配也叫做重载确定，是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。

调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 编译器找不到任何一个函数与实参匹配，发出无匹配的错误信息。
- 有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用的错误信息。

### 重载和作用域

在不同的作用域中无法重载函数名。一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。

```
string read();
void print(const string &);
void print(double);     
void fooBar(int ival)
{
	bool read = false;  
	string s = read();  //@ 错误，read 是一个 bool 变量，并非函数

	void print(int);   
	print("Value: ");   //@ 错误，print(const string &) 已经被隐藏了
	print(ival);    //@ 正确
	print(3.14);     //@ 正确，3.14 会转换成int，void print(double) 被隐藏了
}
```

## 特殊用途语言特性

C++ 有三种函数相关的特性，这些特性并不需要运用于所有函数，而仅当需要时使用。它们分别是默认实参、内联函数和 `constexpr` 函数，以及在程序调试过程中常用的一些功能。

### 默认实参

默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

- 设计带有默认实参的函数的一个原则是将最不可能改变的参数放在最右边。
- 调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。
- 如果想使用默认实参，只要在调用函数的时候省略该实参即可。
- 同一作用域内的多次函数声明，只能提供一次默认值，所有的默认值将叠加起来形成最终的函数声明，即便是相同的多次给出默认值都是错误。如：

```
string screen(sz, sz, char = ' ');
string screen(sz, sz, char = ' '); //@ 声明最后一个参数的默认值多次，即便是相同也是错误的
string screen(sz, sz, char = '*'); //@ 改变默认实参更加是错误的

//@ 增加是可以的，最终将是 string screen(sz=24, sz=80, char=' ');
string screen(sz = 24, sz = 80, char);  
```

- 默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。
- 用于初始化默认实参的值除了可以是常量表达式之外，还可以是全局的变量、函数返回值，但不能是本地变量。作为函数默认实参的表达式中的名字将在函数声明时进行名字解析，而求值发生在函数调用时。另外，如果是内嵌的相同函数声明，将隐藏外部作用的函数声明。

```
sz wd = 80;
char def = ' ';

sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen();   //@ 调用 screen(ht(), 80, ' ')

void f2()
{
    def = '*';      //@ 改变了 def 的值
    sz wd = 100;    //@ 隐藏了外部作用域中的 wd
    window = screen();  //@ 调用的是 screen(ht(), 80, '*')
}
```

### 内联函数

内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字 `inline`。

```
inline const string &horterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

- 在函数声明和定义中都能使用关键字 `inline`，但是建议只在函数定义时使用。
- 一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和 `switch ` 语句，否则函数会被编译为普通函数。

### constexpr函数

`constexpr ` 函数是指能用于常量表达式的函数。

- `constexpr ` 函数的返回类型及所有形参的类型都得是字面值类型。

- C++11标准要求 `constexpr` 函数体中必须有且只有一条 `return` 语句，但可以包含 `typedef` 和 `using` 声明语句或空语句，只要它们不执行任何运行时的操作。但是此限制在C++14标准中被删除。

```
constexpr int new_sz() 
{ 
    return 42; 
}
```

- `constexpr` 函数体所执行的操作必须是编译器可以在编译期间执行的操作，也就是说一定不可以包含内存分配、对象初始化、IO 等操作，即没有运行时操作。

- 编译可以验证 `constexpr` 函数返回的值是常量表达式，并且可以用于初始化 `constexpr` 变量，如果不符合限制，编译器会报错，并不允许编译通过。

- 在符合条件的情况下编译器会将所有的  `constexpr` 函数调用都替换为求值结果。为了让编译器能够求值成功，编译器必须看到所有的 `constexpr` 的函数体代码，所以，隐式要求 `constexpr` 为内联的。

- 接收参数的 `constexpr` 函数当用常量表达式参数进行调用时结果是常量表达式，当用运行时变量调用时结果不是常量表达式。语言是允许这样的操作的，仅当确实需要常量表达式时编译器才会要求 `constexpr` 函数返回常量表达式。如：

```
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

int arr[scale(2)];  //@ 正确
int i = 2;          
int a2[scale(i)];   //@ 错误，scale(i) 并非常量表达式
```

### 调试帮助

C++ 沿用了 C 中使用 `assert` 宏来断言某些不可能的状态，当 `assert` 中表达式求值结果为`false` 将导致程序打印错误信息并退出。

- 使用时需要包含头文件：`<assert.h>`。
- `assert` 宏的行为只有在没有定义宏 `NDEBUG` 时才会执行，可以通过在编译时提供编译选项 `-D NDEBUG` 来禁用掉 `assert` 宏的执行。
- 通常，我们在开发时定义 `assert` ，在生产上线时关闭 `assert` 。

C++  编译器定义几个特殊的预处理变量用于辅助调试：

| 变量名称   | 内容         |
| ---------- | ------------ |
| `__func__` | 当前函数名称 |
| `__FILE__` | 当前文件名称 |
| `__LINE__` | 当前行号     |
| `__TIME__` | 文件编译时间 |
| `__DATE__` | 文件编译日期 |

## 函数调用匹配





## 函数指针





## 