# 函数

## 函数基础

典型的函数定义包括返回类型、函数名字、由0个或多个形式参数组成的列表和函数体。函数执行的操作在函数体中指明。

程序通过调用运算符来执行函数。调用运算符的形式之一是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针.

函数调用完成两项工作：

- 用实参初始化对应的形参。
- 将控制权从主调函数转移给被调函数。此时，主调函数的执行被暂时中断，被调函数开始执行。

`return ` 语句结束函数的执行过程，完成两项工作：

- 返回 `return` 语句中的值（可能没有值）。
- 将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果。

### 形参和实参

- 实参用于初始化形参，C++ 是按照参数顺序进行初始化的，并且不保证实参的求值顺序的。

- 传入的参数必须与形参的类型匹配，并且个数也是必须一致的，因而，所有形参都保证一定会初始化。与初始化一样，允许从参数到形参的转换，只要这种转换是合法的。

- 函数的任意两个形参不能同名，函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

- C++ 中可以用一对空括号表示来表示没有参数，C 中早年必须在括号中写 `void` 来表示没有参数。如：

```
void f() {/*...*/}
void f(void) {/*...*/}
```

- 形参的名字是可选的，但是无法使用未命名的形参。即使某个形参不被函数使用，也必须为它提供一个实参。

### 返回类型

返回类型可以是除数组类型和函数类型外的任何类型，可以是 `void` 类型表示没有没有返回值。

虽然不能返回数组和函数，但是可以返回数组的指针和引用，以及函数指针。

### 局部对象

形参和函数体内定义的变量统称为局部变量。

在变量类型前添加关键字 `static` 可以定义局部静态对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序结束才被销毁，对象所在的函数结束执行并不会对它产生影响。

当局部静态对象没有显式初始化时，将执行值初始化，意味着内置类型的本地静态变量将被初始化为 0。

### 函数声明

和变量类似，函数只能定义一次，但可以声明多次。函数声明也叫做函数原型。

函数声明最好是放在头文件中，以保证所有引入的地方都保持一致，改变声明也仅需改变一个地方。实现函数的源文件也需要包含函数声明，这样可以校验定义和声明是否一致。

### 分离编译

分离式编译允许我们把程序按照逻辑关系分割到几个文件中去，每个文件独立编译。这一过程通常会产生后缀名是 `.obj` 或 `.o` 的文件，该文件包含对象代码。之后编译器把对象文件链接在一起形成可执行文件。

## 参数传递

形参初始化的机理与变量初始化一样。

形参的类型决定了形参和实参交互的方式：

- 当形参是引用类型时，它对应的实参被引用传递，函数被传引用调用。引用形参是它对应实参的别名。
- 当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参（值传递），函数被传值调用。

### 传值参数

如果形参不是引用类型，则函数对形参做的所有操作都不会影响实参。

使用指针类型的形参可以访问或修改函数外部的对象。

```
void reset(int *ip)
{
    *ip = 0;  //@ ip 指向的对象值被改变
    ip = 0;   //@ 局部对象 ip 的值被改变，实参的值没有被改变
}
```

在 C++ 中如果想在函数体内访问或修改函数外部的对象，建议使用引用形参代替指针形参。

### 传引用参数

通过使用引用形参，函数可以改变实参的值。

- 使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。
- 除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。
- 如果函数无须改变引用形参的值，最好将其声明为常量引用。
- 一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。

### const 形参和实参

当形参有顶层 `const` 时，传递给它常量对象或非常量对象都是可以的。对于非 const 引用，用于初始化的实参必须是相同类型的。

把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。所以这里有一个原则就是尽可能使用 `const` 引用。

如果重载的函数只是形参的顶层 `const` 修饰不一样，可以用相同的参数去调用这两个函数，编译器没有足够的信息来区分这两个函数。这种情况下将被认为是重复定义。如：

```
void fcn(const int i) { /* ... */}
void fcn(int i) { /* ... */ }  //@ 错误， 重复定义fcn
```

### 数组形参

因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。

```
//@ 函数参数类型都是 const int*
void print(const int*);
void print(const int[]);    
void print(const int[10]); 
```

- 因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。

- 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。
- 以数组作为形参的函数必须确保使用数组时不会越界。有三种方式来定义数组的边界：
  - 设置一个结束的标记，如：C 风格字符串末尾的空字符。
  - 传入头指针和尾后指针。
  - 传入额外的 size 参数。
- 如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。
- 形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。

```
void print(int (&arr)[10]);   //@ 必须将 & 号放在括号内部
```

- 如果以多维数组作为参数传给函数，那么其实传的是指向二级数组的指针，并且子数组的长度是类型的一部分，因而必须指定其长度。如：

```
void print(int(*matrix)[10], int rowSize); //@  * 号必须放在括号内部，表示指针的优先级高于数组 

//@ 等价于
void print(int matrix[][10], int rowSize);
```

### main：处理命令行选项

可以在命令行中向 `main` 函数传递参数，形式如下：

```
int main(int argc, char *argv[]) { /*...*/ }
int main(int argc, char **argv) { /*...*/ }
```

- 第一个形参 `argc` 表示数组中字符串的数量。
- 第二个形参 `argv` 是一个数组，数组元素是指向 C 风格字符串的指针。
- 当实参传递给 `main` 函数后，`argv` 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

### 含有可变形参的函数

#### C语言中的不定形参

C 语言中使用省略号形式的不定形参，形如：

```
void foo(parm_list, ...);
```

其中省略号只能出现在参数列表的末尾。其中 `parm_list`后的逗号可以省略，但最好不要这样做以免引起歧义。

有几个函数来帮助访问省略号形式的可变参数：

- `va_start` ：使得可以开始访问可变参数。
- `va_arg` ：访问下一个可变参数。
- `va_list` ：保存供 `va_start` `va_arg` `va_end` 访问的信息，必须首先调用。
- `va_end` ：结束访问可变参数。

```
#include <iostream>
#include <cstdarg>

void simple_printf(const char* fmt...)
{
	va_list args;
	va_start(args, fmt);

	while (*fmt != '\0') {
		if (*fmt == 'd') {
			int i = va_arg(args, int);
			std::cout << i << '\n';
		}
		else if (*fmt == 'c') {
			int c = va_arg(args, int);
			std::cout << static_cast<char>(c) << '\n';
		}
		else if (*fmt == 'f') {
			double d = va_arg(args, double);
			std::cout << d << '\n';
		}
		++fmt;
	}

	va_end(args);
}

int main()
{
	simple_printf("dcff", 3, 'a', 1.999, 42.5);
}
```

- 省略号形式的参数是不做类型检查的。
- C++ 还可以使用省略符形参传递可变数量的实参，但这种功能一般只用在与 C 函数交换的接口程序中。
- 在 C++ 中省略号形式的参数中如果有类类型，很可能不能正确的进行拷贝。

#### initializer_list

如果实参类型相同，可以使用 `initializer_list` 标准库类型。

`initializer_list` 是一个类模板，表示某种类型的数组，被定义在头文件 `<initializer_list>` 头文件中。以下简单列举此类对象可以执行的操作：

- `initializer_list<T> lst;` 包含元素类型 T 的空列表。     
- `initializer_list<T> lst{a,b,c...};` 将初始化列表中的值拷贝到列表中，最终列表中的值是 `const` 的。      
- `lst2(lst);` 或者 `lst2 = lst;` 这种形式的初始化或赋值不会拷贝元素，而是共享相同的元素。
- `lst.size();` 返回列表的元素个数；
- `lst.begin();` 和 `lst.end();` 返回头元素和尾后元素的迭代器。

需要记住的是 `initializer_list` 中的元素总是 `const` 的，不能改变其中元素的值。当传递给函数 `initializer_list` 参数时需要将序列放在大括弧中。如：

```
void error_msg(initializer_list<string> il);
error_msg({"functionX", "okay", "expected", "actual"});
```

## 返回类型和return语句

`return ` 语句有两种形式，作用是终止当前正在执行的函数并返回到调用该函数的地方。

```
return;
return expression;
```

### 无返回值函数

- 没有返回值的 `return ` 语句只能用在返回类型是 `void` 的函数中。

- 返回 `void` 的函数可以省略 `return` 语句，因为在这类函数的最后一条语句后面会隐式地执行 `return`。
- 一个返回类型是 `void` 的函数也能使用 `return` 语句的第二种形式，不过此时 `return` 语句的 `expression` 必须是另一个返回 `void` 函数。
- 强行令 `void` 函数返回其他类型的表达式将产生编译错误。

### 有返回值函数

只要函数的返回类型不是 `void`，该函数内的每条 `return` 语句就必须返回一个值，并且返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型（`main` 函数例外）。

函数返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用处的一个临时量，该临时量就是函数调用的结果。

如果函数返回引用类型，则该引用仅仅是它所引用对象的一个别名。函数不应该返回局部对象的指针或引用，因为一旦函数完成，局部对象将被释放。

```
const string &manip()
{
    string ret;
    if (!ret.empty())
        return ret;   //@ 错误，返回局部对象的引用
    else
        return "Empty";   //@ 错误，返回局部对象的引用
}
```



## 函数重载





## 特殊用途语言特性





## 函数调用匹配





## 函数指针





## 