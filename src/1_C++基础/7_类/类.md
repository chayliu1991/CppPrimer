# 类

类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程及设计技术。

- 类的接口包括用户所能执行的操作。
- 类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。

## 定义抽象数据类型

成员函数的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。

成员函数通过一个名为 `this` 的隐式额外参数来访问调用它的对象。`this `参数是一个常量指针，被初始化为调用该函数的对象地址。

- 在函数体内可以显式使用 `this` 指针。
- `this` 是一个 `const` 指针，不能改变 ` this` 使其指向别的对象。

参数列表后的 `const` 用来说明 `this` 指针指向 `const` 对象：

- 通常情况下 `this` 是指向非 `const` 对象的 `const` 指针，不能将非 `const` 的 `this` 指向 `const` 对象，从而不能在 `const` 对象上调用非 `const` 的函数。
- 为了在 `const` 对象上调用成员函数，必须使得 `this` 指向 `const` 对象，所以语言通过在参数列表后放置 `const` 来表明 `this` 指针指向 `const` 对象，从而使得此成员函数称为 `const` 成员函数。
- 常量对象和指向常量对象的引用或指针都只能调用常量成员函数。

### 定义类

#### 类作用域和成员函数

类本身就是一个作用域，所以，成员函数的定义处于类作用域中。

编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话，因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。

#### 在类外部定义成员函数

当在类外部定义成员函数时需要定义与声明完全一致。特别是参数列表后的 `const` 需要一致。

在类外定义的成员名字必须用类名加以限定。

#### 定义函数返回“当前”对象

返回当前对象意味着需要返回当前对象的引用，而且需要在返回时对 `this` 进行解引用。如：

```
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

###  定义类相关的非成员函数

类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。

```
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}

ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```

如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。

### 构造函数

类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。构造函数的工作就是初始化类的数据成员，每当对象创建时构造函数就会调用。

- 构造函数与类名相同而且没有返回值，除此之外与常规函数没有别样。

- 构造函数与常规函数一样可以进行重载。

- 构造函数不能被声明为 `const` 的，原因在于即便是 `const` 对象亦需要在构造函数完成初始化之后才能变成常量。

####  合成默认构造函数

当定义对象时不给定初始值将执行默认初始化。类控制默认初始化的构造函数称为默认构造函数。

- 默认构造函数是没有任何参数。
- 如果类没有显式定义任何构造函数，编译器会隐式定义一个默认构造函数，这个生成的默认构造函数称为合成默认构造函数。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：
  - 如果有类内初始值，就用那个初始值进行初始化。
  - 如果没有，则使用默认初始化，对于类成员将调用其默认构造函数，对于内置类型则不进行任何初始化。

##### 一些类不能依赖于合成默认构造函数

某些类不能依赖于合成的默认构造函数。

- 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。
- 如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。
- 编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。

在 C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加 `=default` 来要求编译器生成构造函数。`=default` 可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果`=default`在类的内部，则默认构造函数是内联的。

##### 构造初始值列表

在 C++11 之后才提供类内初始化，在之前的 C++ 版本是不提供的，此时必须使用构造初始值列表来初始化所有成员。

构造函数初始值列表负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。

当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。

构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。

### 拷贝、赋值和析构

除了定义类对象如何初始化，类还可以控制对象赋值、赋值和销毁时的操作。

- 当初始化变量或者传递参数、返回值时将发生对象复制。

- 当使用赋值操作符时发生赋值操作。
- 当离开定义对象所在的块时将销毁对象，将发生析构。

如果程序员不定义这些操作的函数，编译器将合成这些函数。通常，编译器生成的版本就是将对象的每个成员分别进行拷贝、赋值和销毁。

对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。

## 访问控制和封装

在 C++ 中使用访问说明符来强制封装，即信息隐藏：

- `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
- `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。

一个类可以有零个或多个访问说明符，对于一个访问说明符出现的频率并没有限制。

每个访问说明符说明接下来的成员访问级别，这些访问级别持续到下一个访问说明符的出现或者类的结尾。

#### 使用 class 或 struct 关键字

都可以被用于定义一个类。唯一的却别在于访问权限：

- 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
- 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

#### 友元

类可以允许其他类或函数访问它的非公有成员，方法是使用关键字 `friend` 将其他类或函数声明为它的友元。

- 友元声明需要放在类定义内，它们可以出现在类的任何地方。
- 友元不是类的成员，因而，不受访问控制的影响。
- 将所有的友元声明集中放在一起，或置于类定义头部或尾部，是一个好的处理方式。
- 友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。为了使友元对类的用户可见，就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，通常会把友元的声明与类本身放在同一个头文件中。

#### 封装的益处

- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

## 其它类特性

### 类成员

类可以使用 `typedef` 或 `using` 为类型定义自己的本地名字，由类定义的类型名字可以像其它成员一样定义其访问权限。如：

```
class Screen {
public:
    typedef std::string::size_type pos;
    
//@ 或者
public:
    using pos = std::string::size_type;
};
```

- 在 `public` 部分定义 `pos` 类型，这样用户代码亦可以通过 `Screen::pos` 使用此名字。

- 需要注意的一点是，与常规成员不同，类型别名定义需要出现在任何其被使用之前。因而，类型成员通常出现在类定义的顶部。

### 将成员函数设为 inline





###





## 类作用域





## 构造函数再探





## static 成员





