# 类

类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程及设计技术。

- 类的接口包括用户所能执行的操作。
- 类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。

## 定义抽象数据类型

成员函数的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。

成员函数通过一个名为 `this` 的隐式额外参数来访问调用它的对象。`this `参数是一个常量指针，被初始化为调用该函数的对象地址。

- 在函数体内可以显式使用 `this` 指针。
- `this` 是一个 `const` 指针，不能改变 ` this` 使其指向别的对象。

参数列表后的 `const` 用来说明 `this` 指针指向 `const` 对象：

- 通常情况下 `this` 是指向非 `const` 对象的 `const` 指针，不能将非 `const` 的 `this` 指向 `const` 对象，从而不能在 `const` 对象上调用非 `const` 的函数。
- 为了在 `const` 对象上调用成员函数，必须使得 `this` 指向 `const` 对象，所以语言通过在参数列表后放置 `const` 来表明 `this` 指针指向 `const` 对象，从而使得此成员函数称为 `const` 成员函数。
- 常量对象和指向常量对象的引用或指针都只能调用常量成员函数。

### 定义类

#### 类作用域和成员函数

类本身就是一个作用域，所以，成员函数的定义处于类作用域中。

编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话，因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。

#### 在类外部定义成员函数

当在类外部定义成员函数时需要定义与声明完全一致。特别是参数列表后的 `const` 需要一致。

在类外定义的成员名字必须用类名加以限定。

#### 定义函数返回“当前”对象

返回当前对象意味着需要返回当前对象的引用，而且需要在返回时对 `this` 进行解引用。如：

```
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

###  定义类相关的非成员函数

类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。

```
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}

ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```

如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。

### 构造函数

类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。构造函数的工作就是初始化类的数据成员，每当对象创建时构造函数就会调用。

- 构造函数与类名相同而且没有返回值，除此之外与常规函数没有别样。

- 构造函数与常规函数一样可以进行重载。

- 构造函数不能被声明为 `const` 的，原因在于即便是 `const` 对象亦需要在构造函数完成初始化之后才能变成常量。

####  合成默认构造函数

当定义对象时不给定初始值将执行默认初始化。类控制默认初始化的构造函数称为默认构造函数。

- 默认构造函数是没有任何参数。
- 如果类没有显式定义任何构造函数，编译器会隐式定义一个默认构造函数，这个生成的默认构造函数称为合成默认构造函数。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：
  - 如果有类内初始值，就用那个初始值进行初始化。
  - 如果没有，则使用默认初始化，对于类成员将调用其默认构造函数，对于内置类型则不进行任何初始化。

##### 一些类不能依赖于合成默认构造函数

某些类不能依赖于合成的默认构造函数。

- 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。
- 如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。
- 编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。

在 C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加 `=default` 来要求编译器生成构造函数。`=default` 可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果`=default`在类的内部，则默认构造函数是内联的。

##### 构造初始值列表

在 C++11 之后才提供类内初始化，在之前的 C++ 版本是不提供的，此时必须使用构造初始值列表来初始化所有成员。

构造函数初始值列表负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。

当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。

构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。

### 拷贝、赋值和析构

除了定义类对象如何初始化，类还可以控制对象赋值、赋值和销毁时的操作。

- 当初始化变量或者传递参数、返回值时将发生对象复制。

- 当使用赋值操作符时发生赋值操作。
- 当离开定义对象所在的块时将销毁对象，将发生析构。

如果程序员不定义这些操作的函数，编译器将合成这些函数。通常，编译器生成的版本就是将对象的每个成员分别进行拷贝、赋值和销毁。

对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。

## 访问控制和封装

在 C++ 中使用访问说明符来强制封装，即信息隐藏：

- `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
- `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。

一个类可以有零个或多个访问说明符，对于一个访问说明符出现的频率并没有限制。

每个访问说明符说明接下来的成员访问级别，这些访问级别持续到下一个访问说明符的出现或者类的结尾。

#### 使用 class 或 struct 关键字

都可以被用于定义一个类。唯一的却别在于访问权限：

- 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
- 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

#### 友元

类可以允许其他类或函数访问它的非公有成员，方法是使用关键字 `friend` 将其他类或函数声明为它的友元。

- 友元声明需要放在类定义内，它们可以出现在类的任何地方。
- 友元不是类的成员，因而，不受访问控制的影响。
- 将所有的友元声明集中放在一起，或置于类定义头部或尾部，是一个好的处理方式。
- 友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。为了使友元对类的用户可见，就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，通常会把友元的声明与类本身放在同一个头文件中。

#### 封装的益处

- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

## 其它类特性

### 类成员再探

#### 类中定义类型别名

类可以使用 `typedef` 或 `using` 为类型定义自己的本地名字，由类定义的类型名字可以像其它成员一样定义其访问权限。如：

```
class Screen {
public:
    typedef std::string::size_type pos;
    
//@ 或者
public:
    using pos = std::string::size_type;
};
```

- 在 `public` 部分定义 `pos` 类型，这样用户代码亦可以通过 `Screen::pos` 使用此名字。

- 需要注意的一点是，与常规成员不同，类型别名定义需要出现在任何其被使用之前。因而，类型成员通常出现在类定义的顶部。

#### 将成员函数设为 inline

定义在类内部的成员函数是自动内联的。

可以显式将成员函数声明为 `inline` 的，有两种方式：

- 一种是在类定义内的成员函数声明处声明.
- 另一种是在类外面的成员函数定义处声明。
- 同时在两处都声明内联是合法的。书中认为仅在类外的定义处声明内联可以使得类更加易读。

#### 重载成员函数

与常规函数一样，成员函数亦是可以重载的。而且函数匹配的规则与常规函数的匹配是一样的。

#### mutable数据成员

使用关键字 `mutable` 可以声明可变数据成员。

可变数据成员永远不会是 `const` 的，即使它在 `const` 对象内。因此 `const ` 成员函数可以修改可变成员的值。

#### 类类型数据成员的初始值

在新标准中，除了可以为内置类型数据成员设定类内初始值外，亦可以为类类型数据成员设定初始值。而且，在新标准中最好的设置默认值的方式就是类内初始值。如：

```
class Window_mgr {
private:
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```

- 当初始化类类型成员时，其实是通过提供实参给那个类的构造函数并调用而进行初始化。
- 类内初始值遵循一种格式规范即：要么用等号 `=`形式，要么用大括号  `{}` 形式进行初始化。除此之外的形式都是不合法的。

#### 返回*this的成员函数

函数返回引用即其结果为左值，意味着返回的是对象本身而不是对象的拷贝。如果将操作串连起来就是连续对此对象进行操作。

```
myScreen.move(4, 0).set('#');   //@ move 函数返回 *this，可以继续操作 set
```

如果返回的是对象，而不是引用，那么以上操作中的 `set` 就是对返回的临时量进行操作，而不是对对象本身进行操作：

```
Screen temp = myScreen.move(4, 0);
temp.set('#');
```

`const` 成员函数返回的 `*this` 是一个 `const` 引用，因为，`this` 是一个指向 `const` 对象的指针。这将导致其不能与返回 `*this` 的非 `const` 成员函数串连在一起。

通过区分成员函数是否为 `const` 的，可以对其进行重载：

- 在常量对象上只能调用 `const` 版本的函数。
- 在非常量对象上，尽管两个版本都能调用，但会优先选择非常量版本。

### 类类型

C++ 中的类按名字进行区分，每个类就是一个独特的类型。两个不同的类即便有完全一致的代码亦是不同类型。两个类中的成员是完全独立的。

使用类类型有两种方式：直接使用类的名字，或者在类名前面加上 `class` 或 `struct`，如：

```
Sales_data item1;
class Sales_data item1;
```

#### 类声明

可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明，用于引入类的名字。在类声明之后定义之前都是一个不完全类型。

未完成类型的使用有诸多限制：可以定义这种类型的指针或引用，可以声明（但不能定义）使用未完成类型作为参数或返回值的函数。

只有当知道类的定义时，才能书写创建这种类型对象的代码，否则，编译器不知应当如何存储对象。

一个类不能定义其本身类型的数据成员，但是可以定义本身类型的指针或引用。

### 友元再探

一个类可以使得另一个类作为其友元类，或者将指定特定的成员函数作为其友元。

如果一个友元函数定义在类的内部，这个函数则隐式成为内联的。

#### 类之间的友元关系

友元类的成员函数可以访问授权类的所有成员，包括所有非公有的成员。

友元关系是不可传递的。一个类是另一个类的友元并不意味着这个类自己的友元可以访问那个类，每个类控制着哪些函数或类是自己的友元。

#### 使成员函数成为友元

除了可以使得整个类作为友元，类还可以使得特定的成员函数作为友元。当指定成员函数作为友元时需要指定是哪一个类的成员。如：

```
class Screen {
friend void Window_mgr::clear(ScreenIndex);   //@ 指明成员函数属于哪个类
};
```

尽管重载的函数使用的是同一个名字，它们依然是不同的函数。因而，声明友元函数时必须显式指定其中想要的函数原型，单单声明一个并不会将整个重载的函数集加入进来。如：

```
class Screen {
friend std::ostream &storeOn(std::ostream&, Screen&);
friend BitMap& storeOn(BitMap&, Screen&);
};
```

#### 友元声明和作用域

需要理解的是友元声明仅仅影响访问权限，其并不是真正的声明形式。

```
struct X {
	friend void f() { /* function body */ }
	X() { f(); }  //@ 错误，未声明函数 f
	void g();
	void h();
};

void X::g() { return f(); }  //@ 错误!! f 未声明
void f();
void X::h() { return f(); }  //@正确，此时 f 已经被声明了
```

## 类作用域

每个类定义其自己的新作用域。在类作用域外，必须通过对象、引用或指针以成员访问符来访问数据和函数成员。

#### 定义在类外的成员及其与类作用域的关系

存在类作用域的事实解释了为何在类外定义成员函数时必须同时提供类名和函数名。因为在类外，其成员的名字将被隐藏。

- 一旦遇到了类名，剩下的定义部分（包括形参列表和函数体）就在类作用域内，因此，不需要类名进行限定就可以使用其它类成员

- 当一个成员函数在类外定义时，由于返回类型出现函数名字前，此时作用域并不在类作用域内，因而，必须加上类的名字进行限定。如：

```
Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s);
```

并且，仅在类成员函数定义时才能够在类名后进入类作用域，返回值类型并不会使得进入限定其的类名的作用域。

### 名称查找和类作用域

类定义分为两步：

- 其一，成员的声明被编译。
- 其二，当整个类定义完成时，成员函数定义将被编译。

因此，成员函数体可以使用类中的任何名字。特别是，可以使用在成员函数体后才声明的名字。否则，处理成员声明的顺序将是脆弱而复杂的。

#### 类成员声明的名称查找

对于运用于声明中的名字，包括返回值类型和参数列表中的类型则必须在使用前是可见的。如果成员声明使用了类此刻未见的名字，编译器将在类定义的外部作用域寻找此名字。

```
typedef double Money;
string bal;
class Account {
public:
    //@ Money 使用的是外部声明的，bal 则使用的后面声明的。这是两步走的缘故。
    Money balance() { return bal; }
private:
    Money bal;	//@ 隐藏类外部作用域的名字
};
```

#### 类型名字是特殊的

通常，内部作用域可以重定义外部作用域中的名字，即便那个名字已经被用于内部作用域。

然而，在类中如果一个成员使用了外部作用域中的名字，而此名字是一个类型，那么在类中就不能重定义此名字。如：

```
typedef double Money;
class Account {
public:
    Money balance() { return bal; } //@ Money 是外部作用域的名字
private:
    typedef double Money; //@ 错误!!不能重定义 Money 类型
    Money bal;
};
```

尽管此重定义类型名字是一种错误，编译器并不一定识别此错误。一些编译会静默的接受这样的代码，即便这样的程序是错的。

类型定义应该放在类的头部，这样其它成员就可以看到此类型定义。

**成员函数体内的名字查找规则**

成员函数体中使用的名字通过如下方式进行查找：

- 在成员函数内查找声明，只有出现在使用之前的声明才是可见的；
- 如果未找到，在类定义内查找声明，所有的成员的名字都可见；
- 如果未找到，继续从定义成员函数定义所在的作用域内向上查找，如果成员函数定义在类中则从类外部作用域查找，如果成员函数定义在类外，则从类外的位置向上查找；

通常定义参数名字与别的成员名字一样是不好的行为，如果这样的话，函数内部使用的名字将是参数名字而不是成员名字。可以通过加上类名进行限定而访问成员名字，或者使用 `this` 指针进行访问。然而最好的方式是给参数取一个不同的名字。如：

```
int height;
class Screen {
public:
	typedef std::string::size_type pos;
	void dummy_fcn(pos height)
	{
		cursor = width * height; //@ 访问参数而非成员
		cursor = width * this->height; //@  用 this 访问
		cursor = width * Screen::height; //@ 用类名进行限定
		cursor = width * ::height; //@ 访问全局作用域中的 height
	}
private:
	pos cursor = 0;
	pos height = 0, width = 0;
};
```

如果外部作用域中的名字被类作用域中相同名字给隐藏了，可以通过作用域操作符 `:: ` 显式访问全局中的名字。

#### 名字在它们出现在文件中的位置进行解析

当成员定义在类外时，名字查找的第三步会检查函数定义所在的地方，也会继续往上查找穿过类定义的位置。如：

```
class Screen {
public:
	typedef std::string::size_type pos;
	void setHeight(pos);
	pos height = 0;
};

Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
	height = verify(var);
}
```

这里的 `verify` 是不为类定义 `Screen` 所见的，因而不能运用于类定义中。但是，类外定义的成员函数 `setHeight` 却可以看到此名字，函数体内的名字并不是从类体处开始查找的，而是从函数定义处开始查找的。





## 构造函数再探





## static 成员





